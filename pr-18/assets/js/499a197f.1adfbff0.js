"use strict";(globalThis.webpackChunkmetacall_doc=globalThis.webpackChunkmetacall_doc||[]).push([[2505],{7735:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>a,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"metacall-core/value-types","title":"Value Types","description":"The MetaCall Value Types system provides a unified type representation for cross-language interoperability. This foundational component enables seamless data conversion between different programming languages by defining a common set of data types and operations. Value Types serve as the bridge between language-specific type systems, allowing MetaCall to pass arguments and return values across language boundaries.","source":"@site/docs/metacall-core/value-types.md","sourceDirName":"metacall-core","slug":"/metacall-core/value-types","permalink":"/doc/pr-18/docs/metacall-core/value-types","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Value Types"},"sidebar":"tutorialSidebar","previous":{"title":"Value Handling","permalink":"/doc/pr-18/docs/metacall-core/value-handling"},"next":{"title":"Writing Tests","permalink":"/doc/pr-18/docs/metacall-core/writing-tests"}}');var l=s(4848),r=s(8453);const a={title:"Value Types"},i="Value Types",c={},d=[{value:"Type System Overview",id:"type-system-overview",level:2},{value:"Supported Types",id:"supported-types",level:3},{value:"Value Memory Model",id:"value-memory-model",level:2},{value:"Working with Values",id:"working-with-values",level:2},{value:"Value Creation",id:"value-creation",level:3},{value:"Value Extraction",id:"value-extraction",level:3},{value:"Type Checking",id:"type-checking",level:3},{value:"Value Type Conversion",id:"value-type-conversion",level:2},{value:"Complex Types",id:"complex-types",level:2},{value:"Arrays and Maps",id:"arrays-and-maps",level:3},{value:"Functions and Objects",id:"functions-and-objects",level:3},{value:"Memory Management",id:"memory-management",level:2},{value:"Value Lifecycle",id:"value-lifecycle",level:3},{value:"Serialization Integration",id:"serialization-integration",level:2},{value:"Cross-Language Type Interoperability",id:"cross-language-type-interoperability",level:2},{value:"Error Handling",id:"error-handling",level:2},{value:"Best Practices",id:"best-practices",level:2}];function o(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.header,{children:(0,l.jsx)(n.h1,{id:"value-types",children:"Value Types"})}),"\n",(0,l.jsxs)(n.p,{children:["The MetaCall Value Types system provides a unified type representation for cross-language interoperability. This foundational component enables seamless data conversion between different programming languages by defining a common set of data types and operations. Value Types serve as the bridge between language-specific type systems, allowing MetaCall to pass arguments and return values across language boundaries.\nFor information about serialization formats used with these value types, see ",(0,l.jsx)(n.a,{href:"/doc/pr-18/docs/metacall-core/serialization-formats",children:"Serialization Formats"}),"."]}),"\n",(0,l.jsx)(n.h2,{id:"type-system-overview",children:"Type System Overview"}),"\n",(0,l.jsx)(n.p,{children:"MetaCall's type system consists of primitive types (like integers and strings) and composite types (like arrays and maps). These types are defined as an enumeration in the core API:"}),"\n",(0,l.jsx)(n.h3,{id:"supported-types",children:"Supported Types"}),"\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"Type ID"}),(0,l.jsx)(n.th,{children:"Description"}),(0,l.jsx)(n.th,{children:"C Type Representation"}),(0,l.jsx)(n.th,{children:"Common Usage"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"METACALL_BOOL"}),(0,l.jsx)(n.td,{children:"Boolean value"}),(0,l.jsxs)(n.td,{children:[(0,l.jsx)(n.code,{children:"boolean"})," (unsigned char)"]}),(0,l.jsx)(n.td,{children:"Logical values (true/false)"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"METACALL_CHAR"}),(0,l.jsx)(n.td,{children:"Character"}),(0,l.jsx)(n.td,{children:(0,l.jsx)(n.code,{children:"char"})}),(0,l.jsx)(n.td,{children:"Single character values"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"METACALL_SHORT"}),(0,l.jsx)(n.td,{children:"Short integer"}),(0,l.jsx)(n.td,{children:(0,l.jsx)(n.code,{children:"short"})}),(0,l.jsx)(n.td,{children:"Small numeric values"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"METACALL_INT"}),(0,l.jsx)(n.td,{children:"Integer"}),(0,l.jsx)(n.td,{children:(0,l.jsx)(n.code,{children:"int"})}),(0,l.jsx)(n.td,{children:"Standard numeric values"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"METACALL_LONG"}),(0,l.jsx)(n.td,{children:"Long integer"}),(0,l.jsx)(n.td,{children:(0,l.jsx)(n.code,{children:"long"})}),(0,l.jsx)(n.td,{children:"Larger numeric values"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"METACALL_FLOAT"}),(0,l.jsx)(n.td,{children:"Single-precision float"}),(0,l.jsx)(n.td,{children:(0,l.jsx)(n.code,{children:"float"})}),(0,l.jsx)(n.td,{children:"Decimal values (limited precision)"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"METACALL_DOUBLE"}),(0,l.jsx)(n.td,{children:"Double-precision float"}),(0,l.jsx)(n.td,{children:(0,l.jsx)(n.code,{children:"double"})}),(0,l.jsx)(n.td,{children:"Decimal values (higher precision)"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"METACALL_STRING"}),(0,l.jsx)(n.td,{children:"String"}),(0,l.jsx)(n.td,{children:(0,l.jsx)(n.code,{children:"char *"})}),(0,l.jsx)(n.td,{children:"Text data"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"METACALL_BUFFER"}),(0,l.jsx)(n.td,{children:"Binary buffer"}),(0,l.jsx)(n.td,{children:(0,l.jsx)(n.code,{children:"void *"})}),(0,l.jsx)(n.td,{children:"Raw binary data"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"METACALL_ARRAY"}),(0,l.jsx)(n.td,{children:"Array of values"}),(0,l.jsx)(n.td,{children:(0,l.jsx)(n.code,{children:"value *"})}),(0,l.jsx)(n.td,{children:"Sequential collections of values"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"METACALL_MAP"}),(0,l.jsx)(n.td,{children:"Key-value map"}),(0,l.jsxs)(n.td,{children:[(0,l.jsx)(n.code,{children:"value *"})," (of tuples)"]}),(0,l.jsx)(n.td,{children:"Associative collections of values"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"METACALL_PTR"}),(0,l.jsx)(n.td,{children:"Pointer"}),(0,l.jsx)(n.td,{children:(0,l.jsx)(n.code,{children:"void *"})}),(0,l.jsx)(n.td,{children:"References to arbitrary memory"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"METACALL_FUTURE"}),(0,l.jsx)(n.td,{children:"Async future"}),(0,l.jsx)(n.td,{children:(0,l.jsx)(n.code,{children:"future"})}),(0,l.jsx)(n.td,{children:"Asynchronous operation results"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"METACALL_FUNCTION"}),(0,l.jsx)(n.td,{children:"Function reference"}),(0,l.jsx)(n.td,{children:(0,l.jsx)(n.code,{children:"function"})}),(0,l.jsx)(n.td,{children:"References to callable functions"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"METACALL_NULL"}),(0,l.jsx)(n.td,{children:"Null value"}),(0,l.jsxs)(n.td,{children:[(0,l.jsx)(n.code,{children:"void *"})," (NULL)"]}),(0,l.jsx)(n.td,{children:"Absence of value"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"METACALL_CLASS"}),(0,l.jsx)(n.td,{children:"Class reference"}),(0,l.jsx)(n.td,{children:(0,l.jsx)(n.code,{children:"klass"})}),(0,l.jsx)(n.td,{children:"References to class definitions"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"METACALL_OBJECT"}),(0,l.jsx)(n.td,{children:"Object reference"}),(0,l.jsx)(n.td,{children:(0,l.jsx)(n.code,{children:"object"})}),(0,l.jsx)(n.td,{children:"References to objects"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"METACALL_EXCEPTION"}),(0,l.jsx)(n.td,{children:"Exception"}),(0,l.jsx)(n.td,{children:(0,l.jsx)(n.code,{children:"exception"})}),(0,l.jsx)(n.td,{children:"Error information"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"METACALL_THROWABLE"}),(0,l.jsx)(n.td,{children:"Throwable"}),(0,l.jsx)(n.td,{children:(0,l.jsx)(n.code,{children:"throwable"})}),(0,l.jsx)(n.td,{children:"Encapsulated exceptions"})]})]})]}),"\n",(0,l.jsx)(n.h2,{id:"value-memory-model",children:"Value Memory Model"}),"\n",(0,l.jsx)(n.p,{children:"MetaCall values have a simple but effective memory layout consisting of two parts:"}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Value Data"}),": The actual data content of the value"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Type Header"}),": The type ID metadata appended to the end"]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"The internal representation adds the type ID at the end of the memory block, which allows for efficient value operations while maintaining type safety. This layout enables MetaCall to determine the type of any value at runtime by accessing the type ID at a known offset from the end of the value."}),"\n",(0,l.jsx)(n.h2,{id:"working-with-values",children:"Working with Values"}),"\n",(0,l.jsx)(n.h3,{id:"value-creation",children:"Value Creation"}),"\n",(0,l.jsx)(n.p,{children:"MetaCall provides a comprehensive set of functions for creating values of different types:"}),"\n",(0,l.jsx)(n.p,{children:"Each value type has a corresponding creation function that takes appropriate arguments for that type. For example:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"metacall_value_create_int(int i)"})," creates an integer value"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"metacall_value_create_string(const char *str, size_t length)"})," creates a string value"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"metacall_value_create_array(const void *values[], size_t size)"})," creates an array value"]}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"value-extraction",children:"Value Extraction"}),"\n",(0,l.jsx)(n.p,{children:"To access the data contained in a value, MetaCall provides extraction functions corresponding to each value type:"}),"\n",(0,l.jsx)(n.h3,{id:"type-checking",children:"Type Checking"}),"\n",(0,l.jsx)(n.p,{children:"Type safety is an important aspect of working with MetaCall values. The API provides functions to check the type of a value:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"metacall_value_id(void *v)"})," returns the type ID of a value"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"metacall_value_type_name(void *v)"})," returns a human-readable name of the value's type"]}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"value-type-conversion",children:"Value Type Conversion"}),"\n",(0,l.jsx)(n.p,{children:"MetaCall supports type casting between compatible types. For example, you can cast an integer to a float or a string to a numeric type:"}),"\n",(0,l.jsx)(n.p,{children:"The type conversion system uses rules similar to those in C, with additional support for conversions between more complex types."}),"\n",(0,l.jsx)(n.h2,{id:"complex-types",children:"Complex Types"}),"\n",(0,l.jsx)(n.h3,{id:"arrays-and-maps",children:"Arrays and Maps"}),"\n",(0,l.jsx)(n.p,{children:"Arrays and maps are composite types that can contain multiple values:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Arrays"}),": Ordered collections of values accessible by index"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Maps"}),": Key-value collections where each key maps to a value"]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"For maps, keys and values are stored as tuples (arrays of two elements), where the first element is the key and the second is the value."}),"\n",(0,l.jsx)(n.h3,{id:"functions-and-objects",children:"Functions and Objects"}),"\n",(0,l.jsx)(n.p,{children:"MetaCall also supports more complex types like functions, classes, and objects:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Functions"}),": References to callable code"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Classes"}),": Templates for creating objects"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Objects"}),": Instances of classes with state and behavior"]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"These types are especially important for the foreign function interface, as they allow passing callable functions between language boundaries."}),"\n",(0,l.jsx)(n.h2,{id:"memory-management",children:"Memory Management"}),"\n",(0,l.jsx)(n.h3,{id:"value-lifecycle",children:"Value Lifecycle"}),"\n",(0,l.jsx)(n.p,{children:"MetaCall values must be explicitly destroyed when no longer needed to avoid memory leaks. The API provides functions for managing value lifecycle:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"metacall_value_copy(void *v)"})," creates a deep copy of a value"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"metacall_value_destroy(void *v)"})," frees the memory used by a value"]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"Complex types like functions, objects, and classes use reference counting to manage their lifecycle properly."}),"\n",(0,l.jsx)(n.h2,{id:"serialization-integration",children:"Serialization Integration"}),"\n",(0,l.jsx)(n.p,{children:"The value type system integrates with MetaCall's serialization system, allowing values to be converted to and from string formats like JSON:"}),"\n",(0,l.jsx)(n.p,{children:"The RapidJSON serializer is the default implementation that converts MetaCall values to JSON strings and vice versa. It handles all the value types appropriately:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Primitive types are converted to their JSON equivalents"}),"\n",(0,l.jsx)(n.li,{children:"Arrays become JSON arrays"}),"\n",(0,l.jsx)(n.li,{children:"Maps become JSON objects"}),"\n",(0,l.jsx)(n.li,{children:"Complex types (functions, objects) are serialized as JSON strings"}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"cross-language-type-interoperability",children:"Cross-Language Type Interoperability"}),"\n",(0,l.jsx)(n.p,{children:"One of the primary purposes of the value type system is to facilitate cross-language function calls. When calling a function through MetaCall, arguments are converted from the source language to MetaCall values, then to the target language's native types:"}),"\n",(0,l.jsx)(n.p,{children:"Each language loader in MetaCall implements this bidirectional conversion between the language's native types and MetaCall's value types."}),"\n",(0,l.jsx)(n.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,l.jsx)(n.p,{children:"The value system includes special types for error handling:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"METACALL_EXCEPTION"}),": Represents a caught exception with message, label, and stack trace"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"METACALL_THROWABLE"}),": Wraps an exception value that was thrown but not caught"]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"These types allow exceptions to be propagated across language boundaries, preserving error information."}),"\n",(0,l.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,l.jsx)(n.p,{children:"When working with MetaCall values, follow these best practices:"}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Type Safety"}),": Always check the type of a value before attempting to extract its content"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Memory Management"}),": Destroy values when they are no longer needed to avoid memory leaks"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Type Conversion"}),": Use the appropriate conversion functions when types don't match exactly"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Value Ownership"}),": Be aware of who owns a value and who is responsible for destroying it"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Error Handling"}),": Use METACALL_EXCEPTION and METACALL_THROWABLE for robust error propagation"]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"By following these practices, you can effectively leverage MetaCall's value type system for cross-language interoperability."}),"\n",(0,l.jsxs)(n.p,{children:["Sources: ",(0,l.jsx)(n.a,{href:"https://github.com/metacall/core/blob/af9cad19/source/tests/metacall_test/source/metacall_test.cpp#L224-L274",children:"source/tests/metacall_test/source/metacall_test.cpp224-274"})," ",(0,l.jsx)(n.a,{href:"https://github.com/metacall/core/blob/af9cad19/source/metacall/source/metacall.c#L1139-L1162",children:"source/metacall/source/metacall.c1139-1162"})]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(o,{...e})}):o(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>i});var t=s(6540);const l={},r=t.createContext(l);function a(e){const n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:a(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);