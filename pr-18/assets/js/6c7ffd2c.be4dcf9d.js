"use strict";(globalThis.webpackChunkmetacall_doc=globalThis.webpackChunkmetacall_doc||[]).push([[2406],{6479:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>o,contentTitle:()=>t,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"metacall-core/build-system","title":"Build System","description":"The MetaCall build system provides a flexible and comprehensive way to build, test, and package the MetaCall Core across different platforms. This document explains the architecture and usage of the build system, including environment setup, configuration options, and build workflows for both local development and Docker-based builds.","source":"@site/docs/metacall-core/build-system.md","sourceDirName":"metacall-core","slug":"/metacall-core/build-system","permalink":"/doc/pr-18/docs/metacall-core/build-system","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Build System"},"sidebar":"tutorialSidebar","previous":{"title":"Build Configuration","permalink":"/doc/pr-18/docs/metacall-core/build-configuration"},"next":{"title":"Calling Functions","permalink":"/doc/pr-18/docs/metacall-core/calling-functions"}}');var l=n(4848),d=n(8453);const r={title:"Build System"},t="Build System",o={},c=[{value:"Overview",id:"overview",level:2},{value:"Key Components",id:"key-components",level:2},{value:"Environment Scripts",id:"environment-scripts",level:3},{value:"Configuration Scripts",id:"configuration-scripts",level:3},{value:"CMake Build System",id:"cmake-build-system",level:3},{value:"Docker Build System",id:"docker-build-system",level:3},{value:"Build Workflow",id:"build-workflow",level:2},{value:"Local Build Workflow",id:"local-build-workflow",level:3},{value:"Docker Build Workflow",id:"docker-build-workflow",level:3},{value:"Build Configuration Options",id:"build-configuration-options",level:2},{value:"Build Types",id:"build-types",level:3},{value:"Language Support Options",id:"language-support-options",level:3},{value:"Additional Options",id:"additional-options",level:3},{value:"CMake Integration",id:"cmake-integration",level:2},{value:"Language Loader Configuration",id:"language-loader-configuration",level:2},{value:"Docker Build System",id:"docker-build-system-1",level:2},{value:"Building for Different Platforms",id:"building-for-different-platforms",level:2},{value:"Linux Build",id:"linux-build",level:3},{value:"macOS Build",id:"macos-build",level:3},{value:"Continuous Integration",id:"continuous-integration",level:2},{value:"Conclusion",id:"conclusion",level:2}];function a(e){const i={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,d.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(i.header,{children:(0,l.jsx)(i.h1,{id:"build-system",children:"Build System"})}),"\n",(0,l.jsxs)(i.p,{children:["The MetaCall build system provides a flexible and comprehensive way to build, test, and package the MetaCall Core across different platforms. This document explains the architecture and usage of the build system, including environment setup, configuration options, and build workflows for both local development and Docker-based builds.\nFor information about the overall architecture of MetaCall, see ",(0,l.jsx)(i.a,{href:"/doc/pr-18/docs/metacall-core/architecture",children:"Architecture"}),"."]}),"\n",(0,l.jsx)(i.h2,{id:"overview",children:"Overview"}),"\n",(0,l.jsx)(i.p,{children:"MetaCall's build system is designed to handle the complexity of building a polyglot runtime that supports multiple programming languages and platforms. It consists of several components that work together to provide a seamless build experience."}),"\n",(0,l.jsx)(i.h2,{id:"key-components",children:"Key Components"}),"\n",(0,l.jsx)(i.p,{children:"The build system consists of the following key components:"}),"\n",(0,l.jsx)(i.h3,{id:"environment-scripts",children:"Environment Scripts"}),"\n",(0,l.jsxs)(i.p,{children:["Environment scripts are responsible for setting up dependencies required to build MetaCall. The main script is ",(0,l.jsx)(i.code,{children:"metacall-environment.sh"}),", which installs language runtimes and other dependencies based on command-line options."]}),"\n",(0,l.jsx)(i.p,{children:"Key features of the environment scripts:"}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Platform detection (Linux, macOS)"}),"\n",(0,l.jsx)(i.li,{children:"Linux distribution detection (Debian, Ubuntu, Alpine)"}),"\n",(0,l.jsx)(i.li,{children:"Installation of build dependencies"}),"\n",(0,l.jsx)(i.li,{children:"Installation of language-specific dependencies (Python, Ruby, NodeJS, etc.)"}),"\n"]}),"\n",(0,l.jsx)(i.p,{children:"Example usage:"}),"\n",(0,l.jsx)(i.p,{children:"This would install dependencies for Python, NodeJS, and Ruby loaders."}),"\n",(0,l.jsx)(i.h3,{id:"configuration-scripts",children:"Configuration Scripts"}),"\n",(0,l.jsxs)(i.p,{children:["The configuration script ",(0,l.jsx)(i.code,{children:"metacall-configure.sh"})," is used to configure the CMake build system based on command-line options. It sets various build options like which language loaders to build, build type (Debug/Release), and whether to build tests, examples, etc."]}),"\n",(0,l.jsx)(i.p,{children:"Example usage:"}),"\n",(0,l.jsx)(i.p,{children:"This would configure the CMake build system to build Python, NodeJS, and Ruby loaders."}),"\n",(0,l.jsx)(i.h3,{id:"cmake-build-system",children:"CMake Build System"}),"\n",(0,l.jsxs)(i.p,{children:["MetaCall uses CMake as its primary build system. The main ",(0,l.jsx)(i.code,{children:"CMakeLists.txt"})," file defines the overall project structure, build options, and targets."]}),"\n",(0,l.jsx)(i.p,{children:"Key aspects of the CMake build system:"}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Project configuration options"}),"\n",(0,l.jsx)(i.li,{children:"Dependency management"}),"\n",(0,l.jsx)(i.li,{children:"Build targets for libraries, loaders, and executables"}),"\n",(0,l.jsx)(i.li,{children:"Testing and packaging"}),"\n"]}),"\n",(0,l.jsx)(i.h3,{id:"docker-build-system",children:"Docker Build System"}),"\n",(0,l.jsx)(i.p,{children:"For containerized building and testing, MetaCall provides a Docker-based build system using Docker Compose. This allows for consistent builds across different environments and simplifies the setup process."}),"\n",(0,l.jsx)(i.p,{children:"The Docker build system consists of several services:"}),"\n",(0,l.jsxs)(i.ol,{children:["\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.code,{children:"deps"})," - Base image with all dependencies"]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.code,{children:"dev"})," - Development image with the MetaCall source code and build artifacts"]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.code,{children:"runtime"})," - Runtime image with only the necessary files to run MetaCall"]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.code,{children:"cli"})," - Command-line interface image for running MetaCall"]}),"\n"]}),"\n",(0,l.jsx)(i.h2,{id:"build-workflow",children:"Build Workflow"}),"\n",(0,l.jsx)(i.h3,{id:"local-build-workflow",children:"Local Build Workflow"}),"\n",(0,l.jsx)(i.p,{children:"The typical workflow for building MetaCall locally follows these steps:"}),"\n",(0,l.jsx)(i.h3,{id:"docker-build-workflow",children:"Docker Build Workflow"}),"\n",(0,l.jsxs)(i.p,{children:["For Docker-based builds, the workflow uses the ",(0,l.jsx)(i.code,{children:"docker-compose.sh"})," script:"]}),"\n",(0,l.jsx)(i.h2,{id:"build-configuration-options",children:"Build Configuration Options"}),"\n",(0,l.jsxs)(i.p,{children:["MetaCall provides numerous configuration options to customize the build. These options are passed to the ",(0,l.jsx)(i.code,{children:"metacall-configure.sh"})," script."]}),"\n",(0,l.jsx)(i.h3,{id:"build-types",children:"Build Types"}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.code,{children:"debug"})," - Build with debug symbols and no optimization"]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.code,{children:"release"})," - Build with optimization and no debug symbols"]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.code,{children:"relwithdebinfo"})," - Build with both optimization and debug symbols"]}),"\n"]}),"\n",(0,l.jsx)(i.h3,{id:"language-support-options",children:"Language Support Options"}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.code,{children:"python"})," - Build with Python loader support"]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.code,{children:"ruby"})," - Build with Ruby loader support"]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.code,{children:"nodejs"})," - Build with NodeJS loader support"]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.code,{children:"typescript"})," - Build with TypeScript loader support"]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.code,{children:"v8"})," - Build with V8 JavaScript engine support"]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.code,{children:"netcore"})," - Build with .NET Core support"]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.code,{children:"netcore2"})," - Build with .NET Core 2 support"]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.code,{children:"netcore5"})," - Build with .NET Core 5 support"]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.code,{children:"netcore7"})," - Build with .NET Core 7 support"]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.code,{children:"java"})," - Build with Java support"]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.code,{children:"c"})," - Build with C loader support"]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.code,{children:"cobol"})," - Build with COBOL support"]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.code,{children:"rust"})," - Build with Rust support"]}),"\n"]}),"\n",(0,l.jsx)(i.h3,{id:"additional-options",children:"Additional Options"}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.code,{children:"tests"})," - Build and run tests"]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.code,{children:"examples"})," - Build examples"]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.code,{children:"scripts"})," - Build scripts"]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.code,{children:"benchmarks"})," - Build benchmarks"]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.code,{children:"ports"})," - Build language ports"]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.code,{children:"sandbox"})," - Build with sandboxing support"]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.code,{children:"coverage"})," - Build with code coverage support"]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.code,{children:"address-sanitizer"})," - Build with address sanitizer"]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.code,{children:"thread-sanitizer"})," - Build with thread sanitizer"]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.code,{children:"memory-sanitizer"})," - Build with memory sanitizer"]}),"\n"]}),"\n",(0,l.jsx)(i.h2,{id:"cmake-integration",children:"CMake Integration"}),"\n",(0,l.jsxs)(i.p,{children:["The ",(0,l.jsx)(i.code,{children:"metacall-configure.sh"})," script generates CMake build options based on the command-line arguments and passes them to CMake. These options control which components are built and how they are configured."]}),"\n",(0,l.jsx)(i.p,{children:"The key CMake options include:"}),"\n",(0,l.jsxs)(i.table,{children:[(0,l.jsx)(i.thead,{children:(0,l.jsxs)(i.tr,{children:[(0,l.jsx)(i.th,{children:"Option"}),(0,l.jsx)(i.th,{children:"Description"}),(0,l.jsx)(i.th,{children:"Default"})]})}),(0,l.jsxs)(i.tbody,{children:[(0,l.jsxs)(i.tr,{children:[(0,l.jsx)(i.td,{children:(0,l.jsx)(i.code,{children:"BUILD_SHARED_LIBS"})}),(0,l.jsx)(i.td,{children:"Build shared libraries instead of static"}),(0,l.jsx)(i.td,{children:"ON"})]}),(0,l.jsxs)(i.tr,{children:[(0,l.jsx)(i.td,{children:(0,l.jsx)(i.code,{children:"OPTION_BUILD_TESTS"})}),(0,l.jsx)(i.td,{children:"Build tests"}),(0,l.jsx)(i.td,{children:"ON"})]}),(0,l.jsxs)(i.tr,{children:[(0,l.jsx)(i.td,{children:(0,l.jsx)(i.code,{children:"OPTION_BUILD_BENCHMARKS"})}),(0,l.jsx)(i.td,{children:"Build benchmarks"}),(0,l.jsx)(i.td,{children:"OFF"})]}),(0,l.jsxs)(i.tr,{children:[(0,l.jsx)(i.td,{children:(0,l.jsx)(i.code,{children:"OPTION_BUILD_EXAMPLES"})}),(0,l.jsx)(i.td,{children:"Build examples"}),(0,l.jsx)(i.td,{children:"ON"})]}),(0,l.jsxs)(i.tr,{children:[(0,l.jsx)(i.td,{children:(0,l.jsx)(i.code,{children:"OPTION_BUILD_CLI"})}),(0,l.jsx)(i.td,{children:"Build command line interface"}),(0,l.jsx)(i.td,{children:"ON"})]}),(0,l.jsxs)(i.tr,{children:[(0,l.jsx)(i.td,{children:(0,l.jsx)(i.code,{children:"OPTION_BUILD_LOADERS"})}),(0,l.jsx)(i.td,{children:"Build loaders"}),(0,l.jsx)(i.td,{children:"ON"})]}),(0,l.jsxs)(i.tr,{children:[(0,l.jsx)(i.td,{children:(0,l.jsx)(i.code,{children:"OPTION_BUILD_EXTENSIONS"})}),(0,l.jsx)(i.td,{children:"Build extensions"}),(0,l.jsx)(i.td,{children:"ON"})]}),(0,l.jsxs)(i.tr,{children:[(0,l.jsx)(i.td,{children:(0,l.jsx)(i.code,{children:"OPTION_BUILD_SCRIPTS"})}),(0,l.jsx)(i.td,{children:"Build scripts"}),(0,l.jsx)(i.td,{children:"ON"})]}),(0,l.jsxs)(i.tr,{children:[(0,l.jsx)(i.td,{children:(0,l.jsx)(i.code,{children:"OPTION_BUILD_SERIALS"})}),(0,l.jsx)(i.td,{children:"Build serials"}),(0,l.jsx)(i.td,{children:"ON"})]}),(0,l.jsxs)(i.tr,{children:[(0,l.jsx)(i.td,{children:(0,l.jsx)(i.code,{children:"OPTION_BUILD_DETOURS"})}),(0,l.jsx)(i.td,{children:"Build detours"}),(0,l.jsx)(i.td,{children:"ON"})]}),(0,l.jsxs)(i.tr,{children:[(0,l.jsx)(i.td,{children:(0,l.jsx)(i.code,{children:"OPTION_BUILD_PORTS"})}),(0,l.jsx)(i.td,{children:"Build ports"}),(0,l.jsx)(i.td,{children:"OFF"})]}),(0,l.jsxs)(i.tr,{children:[(0,l.jsx)(i.td,{children:(0,l.jsx)(i.code,{children:"OPTION_COVERAGE"})}),(0,l.jsx)(i.td,{children:"Enable coverage"}),(0,l.jsx)(i.td,{children:"OFF"})]})]})]}),"\n",(0,l.jsx)(i.h2,{id:"language-loader-configuration",children:"Language Loader Configuration"}),"\n",(0,l.jsx)(i.p,{children:"Language loaders in MetaCall require specific configuration to locate their runtime dependencies. The build system generates loader-specific configuration files based on the installed dependencies."}),"\n",(0,l.jsx)(i.p,{children:"The loader configuration works through a set of CMake macros:"}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.code,{children:"loader_configuration_begin(TARGET)"})," - Begin configuration for a loader"]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.code,{children:"loader_configuration_deps(LIBRARY PATHS...)"})," - Define library dependencies"]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.code,{children:"loader_configuartion_end()"})," - Finalize the configuration"]}),"\n"]}),"\n",(0,l.jsx)(i.p,{children:"These macros generate JSON configuration files that tell MetaCall where to find loader dependencies at runtime."}),"\n",(0,l.jsx)(i.h2,{id:"docker-build-system-1",children:"Docker Build System"}),"\n",(0,l.jsx)(i.p,{children:"The Docker build system uses a multi-stage approach to create efficient images:"}),"\n",(0,l.jsxs)(i.ol,{children:["\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.code,{children:"deps"})," stage: Installs all dependencies required for building"]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.code,{children:"dev"})," stage: Builds MetaCall from source"]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.code,{children:"runtime"})," stage: Creates a minimal runtime image"]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.code,{children:"cli"})," stage: Creates a CLI image for command-line usage"]}),"\n"]}),"\n",(0,l.jsxs)(i.p,{children:["The Docker build system is managed through the ",(0,l.jsx)(i.code,{children:"docker-compose.sh"})," script, which provides the following commands:"]}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.code,{children:"build"})," - Build all Docker images"]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.code,{children:"rebuild"})," - Rebuild Docker images without using cache"]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.code,{children:"test"})," - Build and run tests in Docker"]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.code,{children:"test-address-sanitizer"})," - Run tests with address sanitizer"]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.code,{children:"test-thread-sanitizer"})," - Run tests with thread sanitizer"]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.code,{children:"test-memory-sanitizer"})," - Run tests with memory sanitizer"]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.code,{children:"coverage"})," - Build and run tests with coverage"]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.code,{children:"pack"})," - Create distribution packages"]}),"\n"]}),"\n",(0,l.jsx)(i.h2,{id:"building-for-different-platforms",children:"Building for Different Platforms"}),"\n",(0,l.jsx)(i.p,{children:"MetaCall supports building on different platforms, primarily Linux and macOS. The build system automatically detects the platform and adapts the build process accordingly."}),"\n",(0,l.jsx)(i.h3,{id:"linux-build",children:"Linux Build"}),"\n",(0,l.jsx)(i.p,{children:"On Linux, the build system detects the distribution (Debian, Ubuntu, Alpine) and installs the appropriate dependencies. It also sets up the correct build flags for the platform."}),"\n",(0,l.jsx)(i.h3,{id:"macos-build",children:"macOS Build"}),"\n",(0,l.jsx)(i.p,{children:"On macOS, the build system uses Homebrew to install dependencies and sets up the correct build flags for macOS. It also includes specific workarounds for macOS-specific issues."}),"\n",(0,l.jsx)(i.h2,{id:"continuous-integration",children:"Continuous Integration"}),"\n",(0,l.jsx)(i.p,{children:"MetaCall uses GitHub Actions for continuous integration. The Docker build system is used to ensure consistent builds across different environments."}),"\n",(0,l.jsx)(i.p,{children:"The CI process includes:"}),"\n",(0,l.jsxs)(i.ol,{children:["\n",(0,l.jsx)(i.li,{children:"Building the Docker images"}),"\n",(0,l.jsx)(i.li,{children:"Running tests with various sanitizers"}),"\n",(0,l.jsx)(i.li,{children:"Code coverage analysis"}),"\n",(0,l.jsx)(i.li,{children:"Creating distribution packages"}),"\n"]}),"\n",(0,l.jsx)(i.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,l.jsx)(i.p,{children:"The MetaCall build system provides a flexible and robust way to build, test, and package the MetaCall Core. It supports multiple platforms, languages, and build configurations, making it possible to customize the build process to specific needs."}),"\n",(0,l.jsxs)(i.p,{children:["For more information on using MetaCall, see ",(0,l.jsx)(i.a,{href:"/doc/pr-18/docs/metacall-core/overview",children:"Overview"})," and ",(0,l.jsx)(i.a,{href:"/doc/pr-18/docs/metacall-core/architecture",children:"Architecture"}),"."]})]})}function h(e={}){const{wrapper:i}={...(0,d.R)(),...e.components};return i?(0,l.jsx)(i,{...e,children:(0,l.jsx)(a,{...e})}):a(e)}},8453:(e,i,n)=>{n.d(i,{R:()=>r,x:()=>t});var s=n(6540);const l={},d=s.createContext(l);function r(e){const i=s.useContext(d);return s.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function t(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:r(e.components),s.createElement(d.Provider,{value:i},e.children)}}}]);