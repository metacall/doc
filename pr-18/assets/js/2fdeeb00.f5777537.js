"use strict";(globalThis.webpackChunkmetacall_doc=globalThis.webpackChunkmetacall_doc||[]).push([[6411],{8453:(e,i,n)=>{n.d(i,{R:()=>d,x:()=>t});var s=n(6540);const l={},r=s.createContext(l);function d(e){const i=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function t(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:d(e.components),s.createElement(r.Provider,{value:i},e.children)}},9693:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>c,contentTitle:()=>t,default:()=>h,frontMatter:()=>d,metadata:()=>s,toc:()=>o});const s=JSON.parse('{"id":"metacall-core/docker-builds","title":"Docker Builds","description":"This document describes how to use Docker to build, test, and deploy MetaCall. Docker provides a consistent environment for building MetaCall across different platforms and simplifies the development process by isolating dependencies. For information about building MetaCall without Docker, see Build System and Build Configuration.","source":"@site/docs/metacall-core/docker-builds.md","sourceDirName":"metacall-core","slug":"/metacall-core/docker-builds","permalink":"/doc/pr-18/docs/metacall-core/docker-builds","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Docker Builds"},"sidebar":"tutorialSidebar","previous":{"title":"Detours System","permalink":"/doc/pr-18/docs/metacall-core/detours-system"},"next":{"title":"Error Handling","permalink":"/doc/pr-18/docs/metacall-core/error-handling"}}');var l=n(4848),r=n(8453);const d={title:"Docker Builds"},t="Docker Builds",c={},o=[{value:"Overview of MetaCall Docker Build System",id:"overview-of-metacall-docker-build-system",level:2},{value:"Docker Image Structure and Composition",id:"docker-image-structure-and-composition",level:2},{value:"deps Image",id:"deps-image",level:3},{value:"dev Image",id:"dev-image",level:3},{value:"runtime Image",id:"runtime-image",level:3},{value:"cli Image",id:"cli-image",level:3},{value:"Building Docker Images",id:"building-docker-images",level:2},{value:"Basic Build Commands",id:"basic-build-commands",level:3},{value:"Customizing the Build",id:"customizing-the-build",level:3},{value:"Testing with Docker",id:"testing-with-docker",level:2},{value:"Running Basic Tests",id:"running-basic-tests",level:3},{value:"Running Sanitizer Tests",id:"running-sanitizer-tests",level:3},{value:"Running Coverage Analysis",id:"running-coverage-analysis",level:3},{value:"Development Workflow with Docker",id:"development-workflow-with-docker",level:2},{value:"Local Development",id:"local-development",level:3},{value:"Using the CLI Image",id:"using-the-cli-image",level:3},{value:"Distribution and Deployment",id:"distribution-and-deployment",level:2},{value:"Pushing Images to a Registry",id:"pushing-images-to-a-registry",level:3},{value:"Versioning Images",id:"versioning-images",level:3},{value:"Using Build Caching",id:"using-build-caching",level:3},{value:"Creating Distribution Packages",id:"creating-distribution-packages",level:3},{value:"Multi-Platform Builds",id:"multi-platform-builds",level:2},{value:"Environment Variables for Docker Images",id:"environment-variables-for-docker-images",level:2},{value:"Troubleshooting Docker Builds",id:"troubleshooting-docker-builds",level:2}];function a(e){const i={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(i.header,{children:(0,l.jsx)(i.h1,{id:"docker-builds",children:"Docker Builds"})}),"\n",(0,l.jsxs)(i.p,{children:["This document describes how to use Docker to build, test, and deploy MetaCall. Docker provides a consistent environment for building MetaCall across different platforms and simplifies the development process by isolating dependencies. For information about building MetaCall without Docker, see ",(0,l.jsx)(i.a,{href:"/doc/pr-18/docs/metacall-core/build-system",children:"Build System"})," and ",(0,l.jsx)(i.a,{href:"/doc/pr-18/docs/metacall-core/build-configuration",children:"Build Configuration"}),"."]}),"\n",(0,l.jsx)(i.h2,{id:"overview-of-metacall-docker-build-system",children:"Overview of MetaCall Docker Build System"}),"\n",(0,l.jsx)(i.p,{children:"MetaCall uses Docker Compose to manage multiple Docker images that serve different purposes in the development, testing, and deployment workflow. The system consists of four main Docker images arranged in a dependency hierarchy."}),"\n",(0,l.jsx)(i.p,{children:"Each image serves a specific purpose in the MetaCall ecosystem:"}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.strong,{children:"deps"}),": Contains all dependencies required to build MetaCall (compiler, libraries, etc.)"]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.strong,{children:"dev"}),": Contains the built MetaCall from source code, used for development and testing"]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.strong,{children:"runtime"}),": Contains only the runtime dependencies, optimized for production deployments"]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.strong,{children:"cli"}),": Provides a lightweight command-line interface to MetaCall"]}),"\n"]}),"\n",(0,l.jsx)(i.h2,{id:"docker-image-structure-and-composition",children:"Docker Image Structure and Composition"}),"\n",(0,l.jsx)(i.p,{children:"The MetaCall Docker build system is designed as a multi-stage build process where each stage builds upon the previous one:"}),"\n",(0,l.jsx)(i.h3,{id:"deps-image",children:"deps Image"}),"\n",(0,l.jsxs)(i.p,{children:["The ",(0,l.jsx)(i.code,{children:"deps"})," image installs all development dependencies required to build MetaCall, including:"]}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Base build tools (gcc, cmake, git)"}),"\n",(0,l.jsx)(i.li,{children:"Language-specific dependencies (Python, Ruby, NodeJS, etc.)"}),"\n",(0,l.jsx)(i.li,{children:"External libraries (RapidJSON, libffi, etc.)"}),"\n"]}),"\n",(0,l.jsxs)(i.p,{children:["This image is built using the ",(0,l.jsx)(i.code,{children:"metacall-environment.sh"})," script to install dependencies based on configuration options."]}),"\n",(0,l.jsx)(i.h3,{id:"dev-image",children:"dev Image"}),"\n",(0,l.jsxs)(i.p,{children:["The ",(0,l.jsx)(i.code,{children:"dev"})," image builds MetaCall from source using the dependencies installed in the ",(0,l.jsx)(i.code,{children:"deps"})," image. It includes:"]}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Full MetaCall build with all components"}),"\n",(0,l.jsx)(i.li,{children:"Development tools and debugging symbols"}),"\n",(0,l.jsx)(i.li,{children:"Test suite and examples"}),"\n"]}),"\n",(0,l.jsx)(i.p,{children:"This image is primarily used for development and testing and serves as the base for the runtime and CLI images."}),"\n",(0,l.jsx)(i.h3,{id:"runtime-image",children:"runtime Image"}),"\n",(0,l.jsxs)(i.p,{children:["The ",(0,l.jsx)(i.code,{children:"runtime"})," image is a minimal image containing only the components necessary to run MetaCall in production, including:"]}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"MetaCall core libraries"}),"\n",(0,l.jsx)(i.li,{children:"Selected language runtimes (Python, NodeJS, etc.)"}),"\n",(0,l.jsx)(i.li,{children:"Required runtime dependencies"}),"\n"]}),"\n",(0,l.jsx)(i.p,{children:"This image is optimized for deployment and is smaller than the dev image."}),"\n",(0,l.jsx)(i.h3,{id:"cli-image",children:"cli Image"}),"\n",(0,l.jsxs)(i.p,{children:["The ",(0,l.jsx)(i.code,{children:"cli"})," image provides a command-line interface to interact with MetaCall, making it easy to run scripts in different languages:"]}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"MetaCall CLI tool"}),"\n",(0,l.jsx)(i.li,{children:"Minimal dependencies required for CLI operation"}),"\n",(0,l.jsx)(i.li,{children:"Default entry point is the metacall CLI"}),"\n"]}),"\n",(0,l.jsx)(i.p,{children:"This image is used for executing MetaCall commands in CI/CD pipelines or as an interactive development environment."}),"\n",(0,l.jsx)(i.h2,{id:"building-docker-images",children:"Building Docker Images"}),"\n",(0,l.jsxs)(i.p,{children:["MetaCall provides a convenient shell script (",(0,l.jsx)(i.code,{children:"docker-compose.sh"}),") to manage the Docker build process. This script simplifies the building, testing, and deploying of Docker images."]}),"\n",(0,l.jsx)(i.h3,{id:"basic-build-commands",children:"Basic Build Commands"}),"\n",(0,l.jsx)(i.p,{children:"To build all MetaCall Docker images:"}),"\n",(0,l.jsx)(i.p,{children:"This command builds the following images in sequence:"}),"\n",(0,l.jsxs)(i.ol,{children:["\n",(0,l.jsx)(i.li,{children:(0,l.jsx)(i.code,{children:"metacall/core:deps"})}),"\n",(0,l.jsx)(i.li,{children:(0,l.jsx)(i.code,{children:"metacall/core:dev"})}),"\n",(0,l.jsx)(i.li,{children:(0,l.jsx)(i.code,{children:"metacall/core:runtime"})}),"\n",(0,l.jsx)(i.li,{children:(0,l.jsx)(i.code,{children:"metacall/core:cli"})}),"\n"]}),"\n",(0,l.jsx)(i.p,{children:"To rebuild all images without using cached layers:"}),"\n",(0,l.jsx)(i.h3,{id:"customizing-the-build",children:"Customizing the Build"}),"\n",(0,l.jsx)(i.p,{children:"The Docker build process can be customized through environment variables:"}),"\n",(0,l.jsxs)(i.table,{children:[(0,l.jsx)(i.thead,{children:(0,l.jsxs)(i.tr,{children:[(0,l.jsx)(i.th,{children:"Environment Variable"}),(0,l.jsx)(i.th,{children:"Description"}),(0,l.jsx)(i.th,{children:"Default"})]})}),(0,l.jsxs)(i.tbody,{children:[(0,l.jsxs)(i.tr,{children:[(0,l.jsx)(i.td,{children:(0,l.jsx)(i.code,{children:"METACALL_BASE_IMAGE"})}),(0,l.jsx)(i.td,{children:"Base OS image"}),(0,l.jsx)(i.td,{children:(0,l.jsx)(i.code,{children:"debian:buster"})})]}),(0,l.jsxs)(i.tr,{children:[(0,l.jsx)(i.td,{children:(0,l.jsx)(i.code,{children:"METACALL_PATH"})}),(0,l.jsx)(i.td,{children:"Path to MetaCall source code"}),(0,l.jsx)(i.td,{children:(0,l.jsx)(i.code,{children:"/metacall"})})]}),(0,l.jsxs)(i.tr,{children:[(0,l.jsx)(i.td,{children:(0,l.jsx)(i.code,{children:"METACALL_BUILD_TYPE"})}),(0,l.jsx)(i.td,{children:"Build type (debug, release)"}),(0,l.jsx)(i.td,{children:(0,l.jsx)(i.code,{children:"release"})})]}),(0,l.jsxs)(i.tr,{children:[(0,l.jsx)(i.td,{children:(0,l.jsx)(i.code,{children:"METACALL_INSTALL_OPTIONS"})}),(0,l.jsx)(i.td,{children:"Dependencies to install"}),(0,l.jsx)(i.td,{children:"Varies by image"})]}),(0,l.jsxs)(i.tr,{children:[(0,l.jsx)(i.td,{children:(0,l.jsx)(i.code,{children:"METACALL_BUILD_OPTIONS"})}),(0,l.jsx)(i.td,{children:"Components to build"}),(0,l.jsx)(i.td,{children:"Varies by image"})]}),(0,l.jsxs)(i.tr,{children:[(0,l.jsx)(i.td,{children:"These variables can be set before running the build commands:"}),(0,l.jsx)(i.td,{}),(0,l.jsx)(i.td,{})]})]})]}),"\n",(0,l.jsx)(i.h2,{id:"testing-with-docker",children:"Testing with Docker"}),"\n",(0,l.jsx)(i.p,{children:"MetaCall provides specialized Docker configurations for testing, including support for memory sanitizers and code coverage analysis."}),"\n",(0,l.jsx)(i.h3,{id:"running-basic-tests",children:"Running Basic Tests"}),"\n",(0,l.jsx)(i.p,{children:"To build and run tests in Docker:"}),"\n",(0,l.jsx)(i.p,{children:"This command builds the deps and dev images with test configuration and runs the test suite inside the Docker container."}),"\n",(0,l.jsx)(i.h3,{id:"running-sanitizer-tests",children:"Running Sanitizer Tests"}),"\n",(0,l.jsx)(i.p,{children:"For detecting memory errors and other issues, MetaCall supports various sanitizers:"}),"\n",(0,l.jsx)(i.p,{children:"These commands build MetaCall with the corresponding sanitizer enabled and run the test suite."}),"\n",(0,l.jsx)(i.h3,{id:"running-coverage-analysis",children:"Running Coverage Analysis"}),"\n",(0,l.jsx)(i.p,{children:"To generate code coverage reports:"}),"\n",(0,l.jsx)(i.p,{children:"This builds MetaCall with coverage instrumentation enabled and runs the test suite, generating coverage reports that can be viewed in HTML format."}),"\n",(0,l.jsx)(i.h2,{id:"development-workflow-with-docker",children:"Development Workflow with Docker"}),"\n",(0,l.jsx)(i.p,{children:"Here's a typical development workflow using the MetaCall Docker build system:"}),"\n",(0,l.jsx)(i.h3,{id:"local-development",children:"Local Development"}),"\n",(0,l.jsx)(i.p,{children:"When developing locally, you can use Docker volumes to mount your local source code into the Docker container:"}),"\n",(0,l.jsx)(i.p,{children:"This allows you to modify code on your host machine and compile/test it inside the Docker container."}),"\n",(0,l.jsx)(i.h3,{id:"using-the-cli-image",children:"Using the CLI Image"}),"\n",(0,l.jsx)(i.p,{children:"The CLI image provides a convenient way to run MetaCall commands:"}),"\n",(0,l.jsx)(i.p,{children:"This executes the specified script using MetaCall's polyglot runtime."}),"\n",(0,l.jsx)(i.h2,{id:"distribution-and-deployment",children:"Distribution and Deployment"}),"\n",(0,l.jsx)(i.p,{children:"MetaCall Docker images can be distributed and deployed in various ways."}),"\n",(0,l.jsx)(i.h3,{id:"pushing-images-to-a-registry",children:"Pushing Images to a Registry"}),"\n",(0,l.jsx)(i.p,{children:"To push MetaCall images to a Docker registry:"}),"\n",(0,l.jsx)(i.p,{children:"This pushes all four images (deps, dev, runtime, cli) to the specified registry."}),"\n",(0,l.jsx)(i.h3,{id:"versioning-images",children:"Versioning Images"}),"\n",(0,l.jsx)(i.p,{children:"To tag images with a specific version:"}),"\n",(0,l.jsx)(i.p,{children:"This creates version-specific tags based on the version in the VERSION file."}),"\n",(0,l.jsx)(i.h3,{id:"using-build-caching",children:"Using Build Caching"}),"\n",(0,l.jsx)(i.p,{children:"To speed up builds by using a remote cache:"}),"\n",(0,l.jsx)(i.p,{children:"This builds images using layers cached in a remote registry, which can significantly improve build times in CI/CD pipelines."}),"\n",(0,l.jsx)(i.h3,{id:"creating-distribution-packages",children:"Creating Distribution Packages"}),"\n",(0,l.jsx)(i.p,{children:"MetaCall can generate distribution packages (deb, rpm, etc.) using Docker:"}),"\n",(0,l.jsx)(i.p,{children:"This builds packages inside the Docker container and copies them to the specified artifacts path."}),"\n",(0,l.jsx)(i.h2,{id:"multi-platform-builds",children:"Multi-Platform Builds"}),"\n",(0,l.jsx)(i.p,{children:"MetaCall supports building for multiple platforms using Docker's BuildKit:"}),"\n",(0,l.jsx)(i.p,{children:"This builds images for the specified platform, allowing MetaCall to run on different architectures such as ARM64."}),"\n",(0,l.jsx)(i.h2,{id:"environment-variables-for-docker-images",children:"Environment Variables for Docker Images"}),"\n",(0,l.jsx)(i.p,{children:"The following environment variables are used within the Docker containers:"}),"\n",(0,l.jsxs)(i.table,{children:[(0,l.jsx)(i.thead,{children:(0,l.jsxs)(i.tr,{children:[(0,l.jsx)(i.th,{children:"Variable"}),(0,l.jsx)(i.th,{children:"Description"}),(0,l.jsx)(i.th,{children:"Default in Runtime Image"})]})}),(0,l.jsxs)(i.tbody,{children:[(0,l.jsxs)(i.tr,{children:[(0,l.jsx)(i.td,{children:(0,l.jsx)(i.code,{children:"LOADER_LIBRARY_PATH"})}),(0,l.jsx)(i.td,{children:"Path to loader plugins"}),(0,l.jsx)(i.td,{children:(0,l.jsx)(i.code,{children:"/usr/local/lib"})})]}),(0,l.jsxs)(i.tr,{children:[(0,l.jsx)(i.td,{children:(0,l.jsx)(i.code,{children:"LOADER_SCRIPT_PATH"})}),(0,l.jsx)(i.td,{children:"Path to scripts"}),(0,l.jsx)(i.td,{children:(0,l.jsx)(i.code,{children:"/usr/local/scripts"})})]}),(0,l.jsxs)(i.tr,{children:[(0,l.jsx)(i.td,{children:(0,l.jsx)(i.code,{children:"CONFIGURATION_PATH"})}),(0,l.jsx)(i.td,{children:"Path to configuration"}),(0,l.jsx)(i.td,{children:(0,l.jsx)(i.code,{children:"/usr/local/share/metacall/configurations/global.json"})})]}),(0,l.jsxs)(i.tr,{children:[(0,l.jsx)(i.td,{children:(0,l.jsx)(i.code,{children:"SERIAL_LIBRARY_PATH"})}),(0,l.jsx)(i.td,{children:"Path to serial plugins"}),(0,l.jsx)(i.td,{children:(0,l.jsx)(i.code,{children:"/usr/local/lib"})})]}),(0,l.jsxs)(i.tr,{children:[(0,l.jsx)(i.td,{children:(0,l.jsx)(i.code,{children:"DETOUR_LIBRARY_PATH"})}),(0,l.jsx)(i.td,{children:"Path to detour plugins"}),(0,l.jsx)(i.td,{children:(0,l.jsx)(i.code,{children:"/usr/local/lib"})})]}),(0,l.jsxs)(i.tr,{children:[(0,l.jsx)(i.td,{children:(0,l.jsx)(i.code,{children:"PORT_LIBRARY_PATH"})}),(0,l.jsx)(i.td,{children:"Path to port libraries"}),(0,l.jsx)(i.td,{children:(0,l.jsx)(i.code,{children:"/usr/local/lib"})})]}),(0,l.jsxs)(i.tr,{children:[(0,l.jsx)(i.td,{children:(0,l.jsx)(i.code,{children:"NODE_PATH"})}),(0,l.jsx)(i.td,{children:"Path to Node.js modules"}),(0,l.jsx)(i.td,{children:(0,l.jsx)(i.code,{children:"/usr/local/lib/node_modules"})})]}),(0,l.jsxs)(i.tr,{children:[(0,l.jsx)(i.td,{children:"These variables configure the runtime behavior of MetaCall within the Docker containers."}),(0,l.jsx)(i.td,{}),(0,l.jsx)(i.td,{})]})]})]}),"\n",(0,l.jsx)(i.h2,{id:"troubleshooting-docker-builds",children:"Troubleshooting Docker Builds"}),"\n",(0,l.jsx)(i.p,{children:"Common issues when building MetaCall with Docker and their solutions:"}),"\n",(0,l.jsxs)(i.ol,{children:["\n",(0,l.jsxs)(i.li,{children:["\n",(0,l.jsxs)(i.p,{children:[(0,l.jsx)(i.strong,{children:"Build fails with dependency errors"}),":"]}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Check if the base image has changed"}),"\n",(0,l.jsx)(i.li,{children:"Verify that all required dependencies are included in the build options"}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(i.li,{children:["\n",(0,l.jsxs)(i.p,{children:[(0,l.jsx)(i.strong,{children:"Tests fail in Docker but pass locally"}),":"]}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Environment variables might be different"}),"\n",(0,l.jsx)(i.li,{children:"Path issues specific to Docker environment"}),"\n",(0,l.jsx)(i.li,{children:"Check if sanitizers are finding issues that don't manifest locally"}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(i.li,{children:["\n",(0,l.jsxs)(i.p,{children:[(0,l.jsx)(i.strong,{children:"Docker builds are slow"}),":"]}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsx)(i.li,{children:"Use the cache option with a properly configured registry"}),"\n",(0,l.jsx)(i.li,{children:"Consider optimizing the build options to include only necessary components"}),"\n"]}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:i}={...(0,r.R)(),...e.components};return i?(0,l.jsx)(i,{...e,children:(0,l.jsx)(a,{...e})}):a(e)}}}]);