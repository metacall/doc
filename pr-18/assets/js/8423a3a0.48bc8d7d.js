"use strict";(globalThis.webpackChunkmetacall_doc=globalThis.webpackChunkmetacall_doc||[]).push([[2833],{8453:(e,n,l)=>{l.d(n,{R:()=>s,x:()=>t});var a=l(6540);const i={},r=a.createContext(i);function s(e){const n=a.useContext(r);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),a.createElement(r.Provider,{value:n},e.children)}},9555:(e,n,l)=>{l.r(n),l.d(n,{assets:()=>c,contentTitle:()=>t,default:()=>h,frontMatter:()=>s,metadata:()=>a,toc:()=>o});const a=JSON.parse('{"id":"metacall-core/value-handling","title":"Value Handling","description":"The MetaCall Value System is a core component that enables cross-language function calls by providing a common value representation across different programming languages. This page explains how values are represented, created, manipulated, converted, and serialized within the MetaCall framework.","source":"@site/docs/metacall-core/value-handling.md","sourceDirName":"metacall-core","slug":"/metacall-core/value-handling","permalink":"/doc/pr-18/docs/metacall-core/value-handling","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Value Handling"},"sidebar":"tutorialSidebar","previous":{"title":"Testing Framework","permalink":"/doc/pr-18/docs/metacall-core/testing-framework"},"next":{"title":"Value Types","permalink":"/doc/pr-18/docs/metacall-core/value-types"}}');var i=l(4848),r=l(8453);const s={title:"Value Handling"},t="Value Handling",c={},o=[{value:"Value System Architecture",id:"value-system-architecture",level:2},{value:"Value Types",id:"value-types",level:2},{value:"Value Creation and Access",id:"value-creation-and-access",level:2},{value:"Creating Values",id:"creating-values",level:3},{value:"Accessing Values",id:"accessing-values",level:3},{value:"Value Lifecycle Example",id:"value-lifecycle-example",level:3},{value:"Type Conversions",id:"type-conversions",level:2},{value:"Type Casting",id:"type-casting",level:3},{value:"Automatic Type Conversion",id:"automatic-type-conversion",level:3},{value:"Serialization and Deserialization",id:"serialization-and-deserialization",level:2},{value:"Serialization Process",id:"serialization-process",level:3},{value:"Example: Serializing Complex Values",id:"example-serializing-complex-values",level:3},{value:"Memory Management",id:"memory-management",level:2},{value:"Value Lifecycle",id:"value-lifecycle",level:3},{value:"Memory Considerations",id:"memory-considerations",level:3},{value:"Example: Memory Management in Function Calls",id:"example-memory-management-in-function-calls",level:3},{value:"Value Handling in Cross-Language Calls",id:"value-handling-in-cross-language-calls",level:2},{value:"Conclusion",id:"conclusion",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"value-handling",children:"Value Handling"})}),"\n",(0,i.jsxs)(n.p,{children:["The MetaCall Value System is a core component that enables cross-language function calls by providing a common value representation across different programming languages. This page explains how values are represented, created, manipulated, converted, and serialized within the MetaCall framework.\nFor information about calling functions with these values, see ",(0,i.jsx)(n.a,{href:"/doc/pr-18/docs/metacall-core/calling-functions",children:"Calling Functions"}),". For information about how values are serialized and transferred, see ",(0,i.jsx)(n.a,{href:"/doc/pr-18/docs/metacall-core/serialization-and-value-system",children:"Serialization and Value System"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"value-system-architecture",children:"Value System Architecture"}),"\n",(0,i.jsx)(n.p,{children:"The MetaCall Value System acts as a bridge between different programming languages by providing a common representation for data types. Each value in MetaCall encapsulates both the actual data and its type information, allowing for proper interpretation across language boundaries."}),"\n",(0,i.jsx)(n.p,{children:"The value system is built around a few key components:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Value Container"}),": A memory block that stores both type information and actual data"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Type ID System"}),": Enumeration that identifies the data type of a value"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Type Conversions"}),": Mechanisms for converting between different value types"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Value Operations"}),": Functions for creating, accessing, and destroying values"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"value-types",children:"Value Types"}),"\n",(0,i.jsxs)(n.p,{children:["MetaCall supports a wide range of value types, which are defined in the ",(0,i.jsx)(n.code,{children:"metacall_value_id"})," enumeration."]}),"\n",(0,i.jsx)(n.p,{children:"The type system is divided into several categories:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Primitive Types"}),": Boolean, characters, and numeric types (int, long, float, double)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"String Types"}),": Character strings with length information"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Container Types"}),": Arrays and maps for complex data structures"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Special Types"}),": Functions, objects, classes, exceptions, and null values"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Buffer Type"}),": Raw memory buffers for binary data"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Each type has a corresponding human-readable name accessible through the ",(0,i.jsx)(n.code,{children:"metacall_value_id_name()"})," function."]}),"\n",(0,i.jsx)(n.h2,{id:"value-creation-and-access",children:"Value Creation and Access"}),"\n",(0,i.jsx)(n.p,{children:"MetaCall provides a comprehensive API for creating and accessing values of different types."}),"\n",(0,i.jsx)(n.h3,{id:"creating-values",children:"Creating Values"}),"\n",(0,i.jsx)(n.p,{children:"For each supported type, there is a corresponding creation function:"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Function"}),(0,i.jsx)(n.th,{children:"Purpose"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"metacall_value_create_bool(boolean b)"})}),(0,i.jsx)(n.td,{children:"Create a boolean value"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"metacall_value_create_char(char c)"})}),(0,i.jsx)(n.td,{children:"Create a character value"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"metacall_value_create_int(int i)"})}),(0,i.jsx)(n.td,{children:"Create an integer value"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"metacall_value_create_long(long l)"})}),(0,i.jsx)(n.td,{children:"Create a long integer value"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"metacall_value_create_float(float f)"})}),(0,i.jsx)(n.td,{children:"Create a float value"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"metacall_value_create_double(double d)"})}),(0,i.jsx)(n.td,{children:"Create a double value"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"metacall_value_create_string(const char *str, size_t length)"})}),(0,i.jsx)(n.td,{children:"Create a string value"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"metacall_value_create_buffer(const void *buffer, size_t size)"})}),(0,i.jsx)(n.td,{children:"Create a buffer value"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"metacall_value_create_array(const void *values[], size_t size)"})}),(0,i.jsx)(n.td,{children:"Create an array value"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"metacall_value_create_map(const void *tuples[], size_t size)"})}),(0,i.jsx)(n.td,{children:"Create a map value"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"metacall_value_create_null()"})}),(0,i.jsx)(n.td,{children:"Create a null value"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"metacall_value_create_function(void *f)"})}),(0,i.jsx)(n.td,{children:"Create a function value"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"metacall_value_create_class(void *c)"})}),(0,i.jsx)(n.td,{children:"Create a class value"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"metacall_value_create_object(void *o)"})}),(0,i.jsx)(n.td,{children:"Create an object value"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"metacall_value_create_exception(void *ex)"})}),(0,i.jsx)(n.td,{children:"Create an exception value"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"metacall_value_create_throwable(void *th)"})}),(0,i.jsx)(n.td,{children:"Create a throwable value"})]})]})]}),"\n",(0,i.jsx)(n.h3,{id:"accessing-values",children:"Accessing Values"}),"\n",(0,i.jsx)(n.p,{children:"Similarly, to extract data from a value, there are accessor functions:"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Function"}),(0,i.jsx)(n.th,{children:"Purpose"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"metacall_value_to_bool(void *v)"})}),(0,i.jsx)(n.td,{children:"Extract boolean from value"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"metacall_value_to_char(void *v)"})}),(0,i.jsx)(n.td,{children:"Extract character from value"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"metacall_value_to_int(void *v)"})}),(0,i.jsx)(n.td,{children:"Extract integer from value"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"metacall_value_to_long(void *v)"})}),(0,i.jsx)(n.td,{children:"Extract long integer from value"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"metacall_value_to_float(void *v)"})}),(0,i.jsx)(n.td,{children:"Extract float from value"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"metacall_value_to_double(void *v)"})}),(0,i.jsx)(n.td,{children:"Extract double from value"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"metacall_value_to_string(void *v)"})}),(0,i.jsx)(n.td,{children:"Extract string from value"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"metacall_value_to_buffer(void *v)"})}),(0,i.jsx)(n.td,{children:"Extract buffer from value"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"metacall_value_to_array(void *v)"})}),(0,i.jsx)(n.td,{children:"Extract array from value"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"metacall_value_to_map(void *v)"})}),(0,i.jsx)(n.td,{children:"Extract map from value"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"metacall_value_to_null(void *v)"})}),(0,i.jsx)(n.td,{children:"Extract null from value"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"metacall_value_to_function(void *v)"})}),(0,i.jsx)(n.td,{children:"Extract function from value"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"metacall_value_to_class(void *v)"})}),(0,i.jsx)(n.td,{children:"Extract class from value"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"metacall_value_to_object(void *v)"})}),(0,i.jsx)(n.td,{children:"Extract object from value"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"metacall_value_to_exception(void *v)"})}),(0,i.jsx)(n.td,{children:"Extract exception from value"})]})]})]}),"\n",(0,i.jsx)(n.h3,{id:"value-lifecycle-example",children:"Value Lifecycle Example"}),"\n",(0,i.jsx)(n.h2,{id:"type-conversions",children:"Type Conversions"}),"\n",(0,i.jsx)(n.p,{children:"MetaCall provides type conversion capabilities through the value casting system. This is essential for cross-language integration where different type systems need to be reconciled."}),"\n",(0,i.jsx)(n.h3,{id:"type-casting",children:"Type Casting"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"value_type_cast"})," function handles conversions between different value types. It follows these rules:"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"If source and destination types are the same, no conversion is necessary"}),"\n",(0,i.jsx)(n.li,{children:"For numeric types, promotion (widening) or demotion (narrowing) is performed"}),"\n",(0,i.jsx)(n.li,{children:"Conversions that would result in data loss are handled carefully"}),"\n",(0,i.jsx)(n.li,{children:"Special conversions (e.g., between string and numeric types) are supported"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"automatic-type-conversion",children:"Automatic Type Conversion"}),"\n",(0,i.jsx)(n.p,{children:"During function calls, MetaCall attempts to automatically convert values to match the expected parameter types of the function:"}),"\n",(0,i.jsx)(n.p,{children:"This automatic conversion helps smooth the integration between languages with different type systems."}),"\n",(0,i.jsx)(n.h2,{id:"serialization-and-deserialization",children:"Serialization and Deserialization"}),"\n",(0,i.jsx)(n.p,{children:"MetaCall uses serialization to convert values to and from string representations, which is crucial for interprocess communication and persistent storage."}),"\n",(0,i.jsx)(n.h3,{id:"serialization-process",children:"Serialization Process"}),"\n",(0,i.jsx)(n.p,{children:"The RapidJSON implementation handles the serialization of MetaCall values to JSON format. This process involves:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Determining the type of the value"}),"\n",(0,i.jsx)(n.li,{children:"Converting the value to an appropriate JSON representation"}),"\n",(0,i.jsx)(n.li,{children:"Handling special types like functions, objects, and exceptions"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"example-serializing-complex-values",children:"Example: Serializing Complex Values"}),"\n",(0,i.jsx)(n.p,{children:"For complex types like arrays and maps, the serialization process is recursive:"}),"\n",(0,i.jsx)(n.p,{children:"The deserialization process performs the reverse operation, converting JSON data back into MetaCall values."}),"\n",(0,i.jsx)(n.h2,{id:"memory-management",children:"Memory Management"}),"\n",(0,i.jsx)(n.p,{children:"Value handling in MetaCall includes proper memory management to prevent leaks and ensure efficient resource usage."}),"\n",(0,i.jsx)(n.h3,{id:"value-lifecycle",children:"Value Lifecycle"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Creation"}),": Values are created with ",(0,i.jsx)(n.code,{children:"metacall_value_create_*"})," functions, allocating memory"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Reference"}),": Values can be referenced to share data without copying"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Copying"}),": Deep copies are created with ",(0,i.jsx)(n.code,{children:"metacall_value_copy"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Destruction"}),": Values must be explicitly destroyed with ",(0,i.jsx)(n.code,{children:"metacall_value_destroy"})]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"memory-considerations",children:"Memory Considerations"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Values with internal references (like arrays or maps) manage those references recursively"}),"\n",(0,i.jsx)(n.li,{children:"Functions, classes, and objects use reference counting for proper cleanup"}),"\n",(0,i.jsx)(n.li,{children:"When values are passed to function calls, they're automatically copied or cast as needed"}),"\n",(0,i.jsx)(n.li,{children:"When function calls return values, the caller becomes responsible for destroying them"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"example-memory-management-in-function-calls",children:"Example: Memory Management in Function Calls"}),"\n",(0,i.jsx)(n.h2,{id:"value-handling-in-cross-language-calls",children:"Value Handling in Cross-Language Calls"}),"\n",(0,i.jsx)(n.p,{children:"The value system is a critical component in cross-language function calls. Here's an example of how values are processed during a function call:"}),"\n",(0,i.jsx)(n.p,{children:"This process ensures that data can be correctly passed between languages with different type systems."}),"\n",(0,i.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,i.jsx)(n.p,{children:"The MetaCall Value System provides a robust foundation for cross-language interoperability by:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Offering a common representation for values across different programming languages"}),"\n",(0,i.jsx)(n.li,{children:"Supporting a wide range of primitive and complex data types"}),"\n",(0,i.jsx)(n.li,{children:"Providing automatic type conversion when possible"}),"\n",(0,i.jsx)(n.li,{children:"Including serialization capabilities for data transport"}),"\n",(0,i.jsx)(n.li,{children:"Ensuring proper memory management throughout the value lifecycle"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Understanding the value system is essential for effectively using MetaCall to build polyglot applications."})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);