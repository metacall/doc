"use strict";(globalThis.webpackChunkmetacall_doc=globalThis.webpackChunkmetacall_doc||[]).push([[5119],{6567:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"metacall-core/rust-port","title":"Rust Port","description":"The Rust Port provides a Rust language interface to the MetaCall Core, allowing Rust developers to call functions written in other programming languages directly from their Rust applications. This component enables cross-language interoperability, making it possible to integrate code from languages like Python, JavaScript, Ruby, and others into a Rust codebase.","source":"@site/docs/metacall-core/rust-port.md","sourceDirName":"metacall-core","slug":"/metacall-core/rust-port","permalink":"/doc/pr-18/docs/metacall-core/rust-port","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Rust Port"},"sidebar":"tutorialSidebar","previous":{"title":"Rust Loader","permalink":"/doc/pr-18/docs/metacall-core/rust-loader"},"next":{"title":"Sanitizers","permalink":"/doc/pr-18/docs/metacall-core/sanitizers"}}');var r=i(4848),l=i(8453);const s={title:"Rust Port"},o="Rust Port",a={},d=[{value:"Architecture",id:"architecture",level:2},{value:"Rust Port System Structure",id:"rust-port-system-structure",level:3},{value:"FFI Bindings",id:"ffi-bindings",level:2},{value:"Proc Macros for Inline Code",id:"proc-macros-for-inline-code",level:2},{value:"Build System",id:"build-system",level:2},{value:"CMake Integration",id:"cmake-integration",level:3},{value:"Cargo Build Script",id:"cargo-build-script",level:3},{value:"Function Call Flow",id:"function-call-flow",level:2},{value:"API Overview",id:"api-overview",level:2},{value:"Installation and Usage",id:"installation-and-usage",level:2},{value:"Installation",id:"installation",level:3},{value:"Basic Usage",id:"basic-usage",level:3},{value:"Testing",id:"testing",level:2},{value:"Docker Development Environment",id:"docker-development-environment",level:2},{value:"Related Topics",id:"related-topics",level:2}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,l.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"rust-port",children:"Rust Port"})}),"\n",(0,r.jsxs)(n.p,{children:["The Rust Port provides a Rust language interface to the MetaCall Core, allowing Rust developers to call functions written in other programming languages directly from their Rust applications. This component enables cross-language interoperability, making it possible to integrate code from languages like Python, JavaScript, Ruby, and others into a Rust codebase.\nFor information about running Rust code from other languages, see ",(0,r.jsx)(n.a,{href:"/doc/pr-18/docs/metacall-core/rust-loader",children:"Rust Loader"}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"architecture",children:"Architecture"}),"\n",(0,r.jsx)(n.p,{children:"The Rust Port architecture consists of three main components:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"FFI Bindings"}),": Rust bindings to the MetaCall C API generated using bindgen"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Proc Macros"}),": Macros for embedding code from other languages inline in Rust code"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Build Integration"}),": Build scripts that configure linking with the MetaCall Core library"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"rust-port-system-structure",children:"Rust Port System Structure"}),"\n",(0,r.jsx)(n.h2,{id:"ffi-bindings",children:"FFI Bindings"}),"\n",(0,r.jsx)(n.p,{children:"The Rust Port uses bindgen to generate Rust FFI bindings to the MetaCall C API. These bindings provide unsafe Rust functions that directly map to the C API functions."}),"\n",(0,r.jsx)(n.p,{children:"Key MetaCall functions exposed through the bindings include:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"metacall"}),": For calling functions by name"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"metacall_load_from_file"}),": For loading code from files"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"metacall_value_*"}),": Functions for handling MetaCall values"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"The bindings are automatically generated during the build process by the CMake build system, which invokes bindgen with the MetaCall C header files."}),"\n",(0,r.jsx)(n.p,{children:"Important characteristics of these bindings:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Unsafe API"}),": All functions are marked with ",(0,r.jsx)(n.code,{children:"unsafe"})," as they involve FFI calls"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Raw Pointers"}),": Functions use raw pointers (",(0,r.jsx)(n.code,{children:"*mut c_void"}),") for data transfer"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Manual Memory Management"}),": Caller is responsible for freeing allocated resources"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"C-style API"}),": Function names and patterns follow the C API conventions"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"proc-macros-for-inline-code",children:"Proc Macros for Inline Code"}),"\n",(0,r.jsxs)(n.p,{children:["The Rust Port includes proc macros that enable embedding code from other languages directly in Rust code. These macros are defined in the ",(0,r.jsx)(n.code,{children:"inline"})," sub-crate and include:"]}),"\n",(0,r.jsx)(n.p,{children:"This allows writing code like:"}),"\n",(0,r.jsx)(n.p,{children:"The macro parses the embedded code at compile time and generates the necessary Rust code to load and execute it using MetaCall."}),"\n",(0,r.jsx)(n.h2,{id:"build-system",children:"Build System"}),"\n",(0,r.jsx)(n.p,{children:"The Rust Port uses a hybrid build system combining CMake and Cargo:"}),"\n",(0,r.jsx)(n.h3,{id:"cmake-integration",children:"CMake Integration"}),"\n",(0,r.jsx)(n.p,{children:"The CMake configuration:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Checks if the Rust Port is enabled"}),"\n",(0,r.jsx)(n.li,{children:"Finds the Rust toolchain"}),"\n",(0,r.jsx)(n.li,{children:"Generates bindings using bindgen"}),"\n",(0,r.jsx)(n.li,{children:"Invokes Cargo to build the Rust crate"}),"\n",(0,r.jsx)(n.li,{children:"Sets up test environment variables"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"cargo-build-script",children:"Cargo Build Script"}),"\n",(0,r.jsxs)(n.p,{children:["The Cargo build script (",(0,r.jsx)(n.code,{children:"build.rs"}),") configures linking against the MetaCall library:"]}),"\n",(0,r.jsx)(n.h2,{id:"function-call-flow",children:"Function Call Flow"}),"\n",(0,r.jsx)(n.p,{children:"When a function is called through the Rust Port, the following sequence occurs:"}),"\n",(0,r.jsx)(n.h2,{id:"api-overview",children:"API Overview"}),"\n",(0,r.jsx)(n.p,{children:"The Rust Port provides bindings to the MetaCall Core API, enabling:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Loading code from other languages"}),"\n",(0,r.jsx)(n.li,{children:"Calling functions across language boundaries"}),"\n",(0,r.jsx)(n.li,{children:"Converting values between languages"}),"\n",(0,r.jsx)(n.li,{children:"Error handling"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"The bindings are low-level and correspond directly to the C API functions. They require careful memory management and error handling due to their unsafe nature."}),"\n",(0,r.jsxs)(n.p,{children:["For a more detailed description of the underlying API functions, see the ",(0,r.jsx)(n.a,{href:"/doc/pr-18/docs/metacall-core/core-api",children:"Core API"})," page."]}),"\n",(0,r.jsx)(n.h2,{id:"installation-and-usage",children:"Installation and Usage"}),"\n",(0,r.jsx)(n.h3,{id:"installation",children:"Installation"}),"\n",(0,r.jsx)(n.p,{children:"The Rust Port is included in the MetaCall Core repository and is typically built as part of the overall MetaCall build process. To enable it, you need to configure the build with:"}),"\n",(0,r.jsx)(n.h3,{id:"basic-usage",children:"Basic Usage"}),"\n",(0,r.jsx)(n.p,{children:"Based on the available bindings, usage would involve:"}),"\n",(0,r.jsx)(n.p,{children:"This example demonstrates:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Initializing the MetaCall runtime"}),"\n",(0,r.jsx)(n.li,{children:"Loading a Python script"}),"\n",(0,r.jsx)(n.li,{children:"Creating MetaCall values for arguments"}),"\n",(0,r.jsx)(n.li,{children:"Calling a function"}),"\n",(0,r.jsx)(n.li,{children:"Converting the result"}),"\n",(0,r.jsx)(n.li,{children:"Cleaning up resources"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"testing",children:"Testing"}),"\n",(0,r.jsx)(n.p,{children:"The Rust Port includes tests run through Cargo's test framework. The CMake build system sets up the necessary environment variables for the tests:"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Environment Variable"}),(0,r.jsx)(n.th,{children:"Purpose"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"LOADER_LIBRARY_PATH"})}),(0,r.jsx)(n.td,{children:"Path to language loaders"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"LOADER_SCRIPT_PATH"})}),(0,r.jsx)(n.td,{children:"Path to test scripts"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"CONFIGURATION_PATH"})}),(0,r.jsx)(n.td,{children:"Path to MetaCall configuration"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"PROJECT_LIBRARY_PATH_NAME"})}),(0,r.jsx)(n.td,{children:"Path to project libraries"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsxs)(n.td,{children:["The test environment is also configured to support debugging in VS Code through the generation of ",(0,r.jsx)(n.code,{children:".vscode/.env"})," and ",(0,r.jsx)(n.code,{children:"config.toml"})," files."]}),(0,r.jsx)(n.td,{})]})]})]}),"\n",(0,r.jsx)(n.h2,{id:"docker-development-environment",children:"Docker Development Environment"}),"\n",(0,r.jsx)(n.p,{children:"A Docker environment is provided for development:"}),"\n",(0,r.jsx)(n.p,{children:"The Docker image includes all dependencies needed for building and testing the Rust Port, including:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Clang and LLVM for bindgen"}),"\n",(0,r.jsx)(n.li,{children:"Rust toolchain with nightly and clippy components"}),"\n",(0,r.jsx)(n.li,{children:"MetaCall Core built with appropriate options"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"related-topics",children:"Related Topics"}),"\n",(0,r.jsx)(n.p,{children:"For related information, see:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/doc/pr-18/docs/metacall-core/rust-loader",children:"Rust Loader"})," for loading Rust code from other languages"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/doc/pr-18/docs/metacall-core/core-api",children:"Core API"})," for the underlying MetaCall API"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/doc/pr-18/docs/metacall-core/port-system",children:"Port System"})," for an overview of MetaCall ports"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>s,x:()=>o});var t=i(6540);const r={},l=t.createContext(r);function s(e){const n=t.useContext(l);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),t.createElement(l.Provider,{value:n},e.children)}}}]);