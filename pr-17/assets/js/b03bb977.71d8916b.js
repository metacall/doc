"use strict";(globalThis.webpackChunkmetacall_doc=globalThis.webpackChunkmetacall_doc||[]).push([[6731],{5841:e=>{e.exports=JSON.parse('{"version":{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"tutorialSidebar":[{"type":"link","href":"/doc/pr-17/docs/getting-started","label":"Getting Started with MetaCall","docId":"getting-started","unlisted":false},{"type":"link","href":"/doc/pr-17/docs/how-metacall-works","label":"How MetaCall works","docId":"how-metacall-works","unlisted":false},{"type":"category","label":"Installating Metacall CLI","collapsible":true,"collapsed":true,"items":[{"type":"link","href":"/doc/pr-17/docs/installating-metacall-cli/macOS","label":"macOS","docId":"installating-metacall-cli/macOS","unlisted":false},{"type":"link","href":"/doc/pr-17/docs/installating-metacall-cli/Linux","label":"Linux","docId":"installating-metacall-cli/Linux","unlisted":false},{"type":"link","href":"/doc/pr-17/docs/installating-metacall-cli/Windows","label":"Windows","docId":"installating-metacall-cli/Windows","unlisted":false},{"type":"link","href":"/doc/pr-17/docs/installating-metacall-cli/Docker","label":"Docker","docId":"installating-metacall-cli/Docker","unlisted":false}],"href":"/doc/pr-17/docs/category/installating-metacall-cli"},{"type":"category","label":"MetaCall Core","collapsible":true,"collapsed":false,"items":[{"type":"link","href":"/doc/pr-17/docs/metacall-core/architecture","label":"Architecture","docId":"metacall-core/architecture","unlisted":false},{"type":"link","href":"/doc/pr-17/docs/metacall-core/build-configuration","label":"Build Configuration","docId":"metacall-core/build-configuration","unlisted":false},{"type":"link","href":"/doc/pr-17/docs/metacall-core/build-system","label":"Build System","docId":"metacall-core/build-system","unlisted":false},{"type":"link","href":"/doc/pr-17/docs/metacall-core/calling-functions","label":"Calling Functions","docId":"metacall-core/calling-functions","unlisted":false},{"type":"link","href":"/doc/pr-17/docs/metacall-core/cli-commands","label":"CLI Commands","docId":"metacall-core/cli-commands","unlisted":false},{"type":"link","href":"/doc/pr-17/docs/metacall-core/command-line-interface","label":"Command Line Interface","docId":"metacall-core/command-line-interface","unlisted":false},{"type":"link","href":"/doc/pr-17/docs/metacall-core/core-api","label":"Core API","docId":"metacall-core/core-api","unlisted":false},{"type":"link","href":"/doc/pr-17/docs/metacall-core/core-components","label":"Core Components","docId":"metacall-core/core-components","unlisted":false},{"type":"link","href":"/doc/pr-17/docs/metacall-core/creating-custom-loaders","label":"Creating Custom Loaders","docId":"metacall-core/creating-custom-loaders","unlisted":false},{"type":"link","href":"/doc/pr-17/docs/metacall-core/detours-system","label":"Detours System","docId":"metacall-core/detours-system","unlisted":false},{"type":"link","href":"/doc/pr-17/docs/metacall-core/docker-builds","label":"Docker Builds","docId":"metacall-core/docker-builds","unlisted":false},{"type":"link","href":"/doc/pr-17/docs/metacall-core/error-handling","label":"Error Handling","docId":"metacall-core/error-handling","unlisted":false},{"type":"link","href":"/doc/pr-17/docs/metacall-core/features-and-capabilities","label":"Features and Capabilities","docId":"metacall-core/features-and-capabilities","unlisted":false},{"type":"link","href":"/doc/pr-17/docs/metacall-core/go-port","label":"Go Port","docId":"metacall-core/go-port","unlisted":false},{"type":"link","href":"/doc/pr-17/docs/metacall-core/initialization-and-shutdown","label":"Initialization and Shutdown","docId":"metacall-core/initialization-and-shutdown","unlisted":false},{"type":"link","href":"/doc/pr-17/docs/metacall-core/java-loader","label":"Java Loader","docId":"metacall-core/java-loader","unlisted":false},{"type":"link","href":"/doc/pr-17/docs/metacall-core/loader-system","label":"Loader System","docId":"metacall-core/loader-system","unlisted":false},{"type":"link","href":"/doc/pr-17/docs/metacall-core/loaders","label":"Loaders","docId":"metacall-core/loaders","unlisted":false},{"type":"link","href":"/doc/pr-17/docs/metacall-core/loading-code","label":"Loading Code","docId":"metacall-core/loading-code","unlisted":false},{"type":"link","href":"/doc/pr-17/docs/metacall-core/node-js-loader","label":"Node.js Loader","docId":"metacall-core/node-js-loader","unlisted":false},{"type":"link","href":"/doc/pr-17/docs/metacall-core/node-js-port","label":"Node.js Port","docId":"metacall-core/node-js-port","unlisted":false},{"type":"link","href":"/doc/pr-17/docs/metacall-core/overview-core","label":"Overview","docId":"metacall-core/overview-core","unlisted":false},{"type":"link","href":"/doc/pr-17/docs/metacall-core/overview","label":"Overview","docId":"metacall-core/overview","unlisted":false},{"type":"link","href":"/doc/pr-17/docs/metacall-core/port-system","label":"Port System","docId":"metacall-core/port-system","unlisted":false},{"type":"link","href":"/doc/pr-17/docs/metacall-core/ports","label":"Ports","docId":"metacall-core/ports","unlisted":false},{"type":"link","href":"/doc/pr-17/docs/metacall-core/prerequisites","label":"Prerequisites","docId":"metacall-core/prerequisites","unlisted":false},{"type":"link","href":"/doc/pr-17/docs/metacall-core/python-loader","label":"Python Loader","docId":"metacall-core/python-loader","unlisted":false},{"type":"link","href":"/doc/pr-17/docs/metacall-core/python-port","label":"Python Port","docId":"metacall-core/python-port","unlisted":false},{"type":"link","href":"/doc/pr-17/docs/metacall-core/repl-mode","label":"REPL Mode","docId":"metacall-core/repl-mode","unlisted":false},{"type":"link","href":"/doc/pr-17/docs/metacall-core/ruby-loader","label":"Ruby Loader","docId":"metacall-core/ruby-loader","unlisted":false},{"type":"link","href":"/doc/pr-17/docs/metacall-core/ruby-port","label":"Ruby Port","docId":"metacall-core/ruby-port","unlisted":false},{"type":"link","href":"/doc/pr-17/docs/metacall-core/running-tests","label":"Running Tests","docId":"metacall-core/running-tests","unlisted":false},{"type":"link","href":"/doc/pr-17/docs/metacall-core/rust-loader","label":"Rust Loader","docId":"metacall-core/rust-loader","unlisted":false},{"type":"link","href":"/doc/pr-17/docs/metacall-core/rust-port","label":"Rust Port","docId":"metacall-core/rust-port","unlisted":false},{"type":"link","href":"/doc/pr-17/docs/metacall-core/sanitizers","label":"Sanitizers","docId":"metacall-core/sanitizers","unlisted":false},{"type":"link","href":"/doc/pr-17/docs/metacall-core/serialization-and-value-system","label":"Serialization and Value System","docId":"metacall-core/serialization-and-value-system","unlisted":false},{"type":"link","href":"/doc/pr-17/docs/metacall-core/serialization-formats","label":"Serialization Formats","docId":"metacall-core/serialization-formats","unlisted":false},{"type":"link","href":"/doc/pr-17/docs/metacall-core/supported-languages","label":"Supported Languages","docId":"metacall-core/supported-languages","unlisted":false},{"type":"link","href":"/doc/pr-17/docs/metacall-core/testing-framework","label":"Testing Framework","docId":"metacall-core/testing-framework","unlisted":false},{"type":"link","href":"/doc/pr-17/docs/metacall-core/value-handling","label":"Value Handling","docId":"metacall-core/value-handling","unlisted":false},{"type":"link","href":"/doc/pr-17/docs/metacall-core/value-types","label":"Value Types","docId":"metacall-core/value-types","unlisted":false},{"type":"link","href":"/doc/pr-17/docs/metacall-core/writing-tests","label":"Writing Tests","docId":"metacall-core/writing-tests","unlisted":false}]},{"type":"link","href":"/doc/pr-17/docs/understanding-metacall-cli","label":"Understanding MetaCall CLI","docId":"understanding-metacall-cli","unlisted":false},{"type":"category","label":"Using MetaCall","collapsible":true,"collapsed":true,"items":[{"type":"link","href":"/doc/pr-17/docs/using-metacall/javascript","label":"JavaScript","docId":"using-metacall/javascript","unlisted":false}],"href":"/doc/pr-17/docs/category/using-metacall"},{"type":"link","href":"/doc/pr-17/docs/deployment","label":"MetaCall Deploy","docId":"deployment","unlisted":false},{"type":"category","label":"Tutorials","collapsible":true,"collapsed":true,"items":[{"type":"link","href":"/doc/pr-17/docs/tutorials/Climatic","label":"Climatic","docId":"tutorials/Climatic","unlisted":false},{"type":"link","href":"/doc/pr-17/docs/tutorials/treetraversal","label":"Traversing a Polyglot Tree with MetaCall","docId":"tutorials/treetraversal","unlisted":false}],"href":"/doc/pr-17/docs/category/tutorials"},{"type":"link","href":"/doc/pr-17/docs/Gsoc","label":"Google Summer of Code 2025","docId":"Gsoc","unlisted":false},{"type":"link","href":"/doc/pr-17/docs/agents/","label":"MetaCall Core - Comprehensive Documentation Summary","docId":"agents/agents","unlisted":false}]},"docs":{"agents/agents":{"id":"agents/agents","title":"MetaCall Core - Comprehensive Documentation Summary","description":"Executive Summary","sidebar":"tutorialSidebar"},"deployment":{"id":"deployment","title":"MetaCall Deploy","description":"","sidebar":"tutorialSidebar"},"getting-started":{"id":"getting-started","title":"Getting Started with MetaCall","description":"Metacall is a polyglot tool that allows calling functions, methods, procedures between different programming languages.","sidebar":"tutorialSidebar"},"Gsoc":{"id":"Gsoc","title":"Google Summer of Code 2025","description":"List of project ideas for contributors applying to the Google Summer of Code program in 2025 (GSoC 2025).","sidebar":"tutorialSidebar"},"how-metacall-works":{"id":"how-metacall-works","title":"How MetaCall works","description":"Metacall is a runtime that allows you to seamlessly connect and interoperate between multiple programming languages. It acts as a bridge, enabling you to call functions from one language in another without worrying about compatibility issues.","sidebar":"tutorialSidebar"},"installating-metacall-cli/Docker":{"id":"installating-metacall-cli/Docker","title":"Docker","description":"Guide to install Metacall CLI on Docker.","sidebar":"tutorialSidebar"},"installating-metacall-cli/Linux":{"id":"installating-metacall-cli/Linux","title":"Linux","description":"Guide to install Metacall CLI on Linux.","sidebar":"tutorialSidebar"},"installating-metacall-cli/macOS":{"id":"installating-metacall-cli/macOS","title":"macOS","description":"Guide to install Metacall CLI on macOS.","sidebar":"tutorialSidebar"},"installating-metacall-cli/Windows":{"id":"installating-metacall-cli/Windows","title":"Windows","description":"Guide to install Metacall CLI on Windows.","sidebar":"tutorialSidebar"},"metacall-core/architecture":{"id":"metacall-core/architecture","title":"Architecture","description":"This page provides a comprehensive overview of the MetaCall Core architecture, explaining the structure and interactions between key components that enable cross-language function calls. For information about specific language support, see Supported Languages, and for details about using the core API, see Core API.","sidebar":"tutorialSidebar"},"metacall-core/build-configuration":{"id":"metacall-core/build-configuration","title":"Build Configuration","description":"This page describes how to configure the MetaCall Core build system to enable different features, language loaders, and build options. It explains the various configuration scripts, available options, and how to customize your build based on your requirements.","sidebar":"tutorialSidebar"},"metacall-core/build-system":{"id":"metacall-core/build-system","title":"Build System","description":"The MetaCall build system provides a flexible and comprehensive way to build, test, and package the MetaCall Core across different platforms. This document explains the architecture and usage of the build system, including environment setup, configuration options, and build workflows for both local development and Docker-based builds.","sidebar":"tutorialSidebar"},"metacall-core/calling-functions":{"id":"metacall-core/calling-functions","title":"Calling Functions","description":"This document explains how to use MetaCall to call functions across language boundaries, including different API variations, argument handling, and value conversion. For information about loading code before calling functions, see Loading Code.","sidebar":"tutorialSidebar"},"metacall-core/cli-commands":{"id":"metacall-core/cli-commands","title":"CLI Commands","description":"This page documents the MetaCall Command Line Interface (CLI) commands and their usage. The CLI provides a way to interact with MetaCall\'s polyglot runtime through command-line arguments and a Read-Eval-Print Loop (REPL) interface. For information about the REPL mode specifically, see REPL Mode.","sidebar":"tutorialSidebar"},"metacall-core/command-line-interface":{"id":"metacall-core/command-line-interface","title":"Command Line Interface","description":"The MetaCall Command Line Interface (CLI) provides a versatile environment for executing code in multiple programming languages, offering both direct script execution and an interactive REPL (Read-Eval-Print Loop) mode. This document explains the architecture and usage of the MetaCall CLI tool.","sidebar":"tutorialSidebar"},"metacall-core/core-api":{"id":"metacall-core/core-api","title":"Core API","description":"The MetaCall Core API provides the fundamental interface for interoperating between different programming languages. It enables loading code from various languages, executing functions across language boundaries, and handling data conversion between different type systems.","sidebar":"tutorialSidebar"},"metacall-core/core-components":{"id":"metacall-core/core-components","title":"Core Components","description":"The Core Components form the foundation of MetaCall, providing essential functionality for cross-language function calls. This page details the internal systems that enable code written in different programming languages to seamlessly interact: the Core API, reflection system, value system, serialization, and detour mechanisms.","sidebar":"tutorialSidebar"},"metacall-core/creating-custom-loaders":{"id":"metacall-core/creating-custom-loaders","title":"Creating Custom Loaders","description":"This guide explains how to create custom language loaders for MetaCall. Loaders are plugins that enable MetaCall to execute code written in specific programming languages. By creating a custom loader, you can add support for languages not currently integrated into MetaCall or implement specialized versions of existing language runtimes.","sidebar":"tutorialSidebar"},"metacall-core/detours-system":{"id":"metacall-core/detours-system","title":"Detours System","description":"The Detours System is a core component of MetaCall that enables function hooking, interception, and redirection at runtime. It allows MetaCall to intercept function calls and redirect them to alternative implementations, which is essential for cross-language function calls and ensuring thread safety in forked processes. This system is critical for MetaCall\'s ability to seamlessly integrate code from different programming languages.","sidebar":"tutorialSidebar"},"metacall-core/docker-builds":{"id":"metacall-core/docker-builds","title":"Docker Builds","description":"This document describes how to use Docker to build, test, and deploy MetaCall. Docker provides a consistent environment for building MetaCall across different platforms and simplifies the development process by isolating dependencies. For information about building MetaCall without Docker, see Build System and Build Configuration.","sidebar":"tutorialSidebar"},"metacall-core/error-handling":{"id":"metacall-core/error-handling","title":"Error Handling","description":"This page documents the error handling mechanisms in MetaCall Core, explaining how errors are represented, propagated, and handled across language boundaries. It covers the exception system, return codes, error logging, and best practices for handling errors when using MetaCall.","sidebar":"tutorialSidebar"},"metacall-core/features-and-capabilities":{"id":"metacall-core/features-and-capabilities","title":"Features and Capabilities","description":"This page provides a comprehensive overview of MetaCall\'s core features and capabilities as a polyglot runtime environment. MetaCall enables seamless cross-language function calls, allowing developers to write and execute code in multiple programming languages within the same application. For information about specific language implementations, see Supported Languages.","sidebar":"tutorialSidebar"},"metacall-core/go-port":{"id":"metacall-core/go-port","title":"Go Port","description":"The Go Port enables Go applications to interoperate with code written in other programming languages supported by MetaCall. This port provides a thin wrapper around the MetaCall C API, allowing Go developers to load and execute code written in Python, JavaScript, Ruby, and other languages directly from Go code.","sidebar":"tutorialSidebar"},"metacall-core/initialization-and-shutdown":{"id":"metacall-core/initialization-and-shutdown","title":"Initialization and Shutdown","description":"This page documents the initialization and shutdown procedures for the MetaCall runtime environment across different programming languages. Proper initialization is essential for setting up the runtime environment before making cross-language function calls, while orderly shutdown ensures resources are released correctly.","sidebar":"tutorialSidebar"},"metacall-core/java-loader":{"id":"metacall-core/java-loader","title":"Java Loader","description":"The Java Loader is a component of the MetaCall Core that enables execution of Java code and interoperability between Java and other programming languages supported by MetaCall. This page documents the architecture, implementation, and functionality of the Java Loader.","sidebar":"tutorialSidebar"},"metacall-core/loader-system":{"id":"metacall-core/loader-system","title":"Loader System","description":"The Loader System is a core component of MetaCall that enables loading, executing, and interoperating with code written in different programming languages. This system acts as a bridge between the MetaCall core and language-specific runtimes (such as Python, Node.js, Ruby), providing standardized mechanisms to load code and invoke functions across language boundaries.","sidebar":"tutorialSidebar"},"metacall-core/loaders":{"id":"metacall-core/loaders","title":"Loaders","description":"Loaders are a fundamental component of the MetaCall system, responsible for loading and executing code from different programming languages. Each loader acts as a bridge between the MetaCall Core and a specific language runtime, enabling cross-language function calls. This document provides a detailed overview of the loader architecture, implementation, and the various language loaders supported by MetaCall.","sidebar":"tutorialSidebar"},"metacall-core/loading-code":{"id":"metacall-core/loading-code","title":"Loading Code","description":"This document details the methods and processes for loading source code from various programming languages into the MetaCall runtime. Loading code is a fundamental operation in MetaCall that allows functions written in different languages to be callable from any supported language in the MetaCall ecosystem.","sidebar":"tutorialSidebar"},"metacall-core/node-js-loader":{"id":"metacall-core/node-js-loader","title":"Node.js Loader","description":"The Node.js Loader enables MetaCall to load, execute, and interact with JavaScript code running in the Node.js runtime. This loader is a core component that bridges the gap between the Node.js ecosystem and other language runtimes within MetaCall, enabling seamless interoperability between JavaScript and other supported languages.","sidebar":"tutorialSidebar"},"metacall-core/node-js-port":{"id":"metacall-core/node-js-port","title":"Node.js Port","description":"This document describes the Node.js Port for MetaCall, a component that enables Node.js applications to call functions from other programming languages through MetaCall\'s foreign function interface. The Node.js Port provides a familiar JavaScript API for Node.js developers to seamlessly integrate with code written in Python, Ruby, C#, and other languages supported by MetaCall.","sidebar":"tutorialSidebar"},"metacall-core/overview":{"id":"metacall-core/overview","title":"Overview","description":"MetaCall is a polyglot runtime that enables cross-language function interface calls. It allows developers to seamlessly call functions, methods, and procedures between different programming languages, effectively breaking down language barriers in software development.","sidebar":"tutorialSidebar"},"metacall-core/overview-core":{"id":"metacall-core/overview-core","title":"Overview","description":"MetaCall is a polyglot runtime that enables cross-language function interface calls. It allows developers to seamlessly call functions, methods, and procedures between different programming languages, effectively breaking down language barriers in software development.","sidebar":"tutorialSidebar"},"metacall-core/port-system":{"id":"metacall-core/port-system","title":"Port System","description":"The Port System in MetaCall provides language-specific interfaces that allow developers to use MetaCall\'s cross-language function call capabilities naturally from their preferred programming language. Ports act as bridges between the MetaCall Core and various programming language environments, enabling seamless integration of MetaCall functionality into applications written in languages like Node.js, Python, Ruby, Rust, and others.","sidebar":"tutorialSidebar"},"metacall-core/ports":{"id":"metacall-core/ports","title":"Ports","description":"Ports in MetaCall are language-specific interfaces that allow developers to use MetaCall\'s cross-language function call capabilities from their preferred programming language. They bridge MetaCall Core functionality to specific language environments, providing a natural and idiomatic way to access foreign language code.","sidebar":"tutorialSidebar"},"metacall-core/prerequisites":{"id":"metacall-core/prerequisites","title":"Prerequisites","description":"This page documents the system requirements and dependencies needed to build, install, and run MetaCall Core. It covers required development tools, compilers, language runtimes, and libraries for all supported platforms. For information about configuring the build system after installing prerequisites, see Build Configuration.","sidebar":"tutorialSidebar"},"metacall-core/python-loader":{"id":"metacall-core/python-loader","title":"Python Loader","description":"The Python Loader is a core component of MetaCall that enables loading and executing Python code at runtime, providing interoperability between Python and other programming languages supported by the MetaCall framework. This document covers the internal architecture, functionality, and implementation details of the Python Loader.","sidebar":"tutorialSidebar"},"metacall-core/python-port":{"id":"metacall-core/python-port","title":"Python Port","description":"The Python Port provides a bridge between Python applications and MetaCall\'s cross-language function invocation capabilities. It allows Python code to seamlessly call functions written in other languages (like JavaScript, Ruby, C#) and exposes Python functions to be called from other languages.","sidebar":"tutorialSidebar"},"metacall-core/repl-mode":{"id":"metacall-core/repl-mode","title":"REPL Mode","description":"The MetaCall REPL (Read-Eval-Print Loop) provides an interactive shell environment for executing cross-language function calls and managing code loading across different programming languages. This page documents the REPL mode implementation, its architecture, and usage patterns.","sidebar":"tutorialSidebar"},"metacall-core/ruby-loader":{"id":"metacall-core/ruby-loader","title":"Ruby Loader","description":"The Ruby Loader is a plugin for MetaCall Core that enables loading, executing, and interfacing with Ruby code at runtime. This component allows Ruby functions, objects, and classes to be called from other programming languages supported by MetaCall, and vice versa.","sidebar":"tutorialSidebar"},"metacall-core/ruby-port":{"id":"metacall-core/ruby-port","title":"Ruby Port","description":"The Ruby Port in MetaCall provides Ruby developers with the ability to use the MetaCall foreign function interface within Ruby applications. This allows Ruby code to seamlessly load and execute functions written in other programming languages like Python, JavaScript, C#, and more. This page documents the architecture, usage, and implementation of the Ruby Port.","sidebar":"tutorialSidebar"},"metacall-core/running-tests":{"id":"metacall-core/running-tests","title":"Running Tests","description":"This page provides comprehensive guidance on executing tests within the MetaCall Core project. It covers running tests locally across different platforms, using sanitizers, and navigating test output. For information about writing new tests, see Writing Tests.","sidebar":"tutorialSidebar"},"metacall-core/rust-loader":{"id":"metacall-core/rust-loader","title":"Rust Loader","description":"Overview","sidebar":"tutorialSidebar"},"metacall-core/rust-port":{"id":"metacall-core/rust-port","title":"Rust Port","description":"The Rust Port provides a Rust language interface to the MetaCall Core, allowing Rust developers to call functions written in other programming languages directly from their Rust applications. This component enables cross-language interoperability, making it possible to integrate code from languages like Python, JavaScript, Ruby, and others into a Rust codebase.","sidebar":"tutorialSidebar"},"metacall-core/sanitizers":{"id":"metacall-core/sanitizers","title":"Sanitizers","description":"Sanitizers are powerful diagnostic tools integrated into the MetaCall build system to detect runtime errors that might otherwise be difficult to find. This page documents the sanitizer options available in MetaCall, how they are configured, and how they are used in the continuous integration (CI) pipeline for quality assurance.","sidebar":"tutorialSidebar"},"metacall-core/serialization-and-value-system":{"id":"metacall-core/serialization-and-value-system","title":"Serialization and Value System","description":"The MetaCall Serialization and Value System provides a unified way to represent and convert data between different programming languages, as well as serialize and deserialize this data for storage or transmission. This is a core component of MetaCall that enables seamless cross-language interoperability.","sidebar":"tutorialSidebar"},"metacall-core/serialization-formats":{"id":"metacall-core/serialization-formats","title":"Serialization Formats","description":"Overview","sidebar":"tutorialSidebar"},"metacall-core/supported-languages":{"id":"metacall-core/supported-languages","title":"Supported Languages","description":"This page provides a comprehensive overview of programming languages supported by MetaCall, including their integration levels, supported features, and implementation details. For information about the general architecture of MetaCall, see Architecture.","sidebar":"tutorialSidebar"},"metacall-core/testing-framework":{"id":"metacall-core/testing-framework","title":"Testing Framework","description":"The MetaCall testing framework provides a comprehensive suite of tools and methodologies for ensuring code quality, correctness, and reliability across the codebase. This page describes the architecture, components, and usage of the testing infrastructure within the MetaCall project. For information about benchmarking, see page 8.3 on Sanitizers.","sidebar":"tutorialSidebar"},"metacall-core/value-handling":{"id":"metacall-core/value-handling","title":"Value Handling","description":"The MetaCall Value System is a core component that enables cross-language function calls by providing a common value representation across different programming languages. This page explains how values are represented, created, manipulated, converted, and serialized within the MetaCall framework.","sidebar":"tutorialSidebar"},"metacall-core/value-types":{"id":"metacall-core/value-types","title":"Value Types","description":"The MetaCall Value Types system provides a unified type representation for cross-language interoperability. This foundational component enables seamless data conversion between different programming languages by defining a common set of data types and operations. Value Types serve as the bridge between language-specific type systems, allowing MetaCall to pass arguments and return values across language boundaries.","sidebar":"tutorialSidebar"},"metacall-core/writing-tests":{"id":"metacall-core/writing-tests","title":"Writing Tests","description":"This document provides a comprehensive guide for writing and running tests for the MetaCall project. It covers the testing infrastructure, how to create new tests, and best practices for testing different language loaders and cross-language functionality.","sidebar":"tutorialSidebar"},"tutorials/Climatic":{"id":"tutorials/Climatic","title":"Climatic","description":"Building a Polyglot Weather Dashboard with MetaCall","sidebar":"tutorialSidebar"},"tutorials/treetraversal":{"id":"tutorials/treetraversal","title":"Traversing a Polyglot Tree with MetaCall","description":"A comprehensive guide to implementing and visualizing tree traversal across multiple programming languages using MetaCall.","sidebar":"tutorialSidebar"},"understanding-metacall-cli":{"id":"understanding-metacall-cli","title":"Understanding MetaCall CLI","description":"This document will guide you through the basic commands of MetaCall CLI, explaining each one with simple examples to help you get started.","sidebar":"tutorialSidebar"},"using-metacall/javascript":{"id":"using-metacall/javascript","title":"JavaScript","description":"Works for JavaScript, TypeScript, NodeJS.","sidebar":"tutorialSidebar"}}}}')}}]);