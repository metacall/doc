"use strict";(globalThis.webpackChunkmetacall_doc=globalThis.webpackChunkmetacall_doc||[]).push([[3817],{5703:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"metacall-core/supported-languages","title":"Supported Languages","description":"This page provides a comprehensive overview of programming languages supported by MetaCall, including their integration levels, supported features, and implementation details. For information about the general architecture of MetaCall, see Architecture.","source":"@site/docs/metacall-core/supported-languages.md","sourceDirName":"metacall-core","slug":"/metacall-core/supported-languages","permalink":"/doc/pr-17/docs/metacall-core/supported-languages","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Supported Languages"},"sidebar":"tutorialSidebar","previous":{"title":"Serialization Formats","permalink":"/doc/pr-17/docs/metacall-core/serialization-formats"},"next":{"title":"Testing Framework","permalink":"/doc/pr-17/docs/metacall-core/testing-framework"}}');var s=t(4848),l=t(8453);const r={title:"Supported Languages"},a="Supported Languages",d={},o=[{value:"Language Support Overview",id:"language-support-overview",level:2},{value:"Integration Levels",id:"integration-levels",level:2},{value:"Feature Support Matrix",id:"feature-support-matrix",level:2},{value:"Python Support",id:"python-support",level:2},{value:"Features",id:"features",level:3},{value:"Implementation Details",id:"implementation-details",level:3},{value:"Node.js Support",id:"nodejs-support",level:2},{value:"Features",id:"features-1",level:3},{value:"Implementation Details",id:"implementation-details-1",level:3},{value:"TypeScript Support",id:"typescript-support",level:2},{value:"Features",id:"features-2",level:3},{value:"Implementation Details",id:"implementation-details-2",level:3},{value:"Ruby Support",id:"ruby-support",level:2},{value:"Features",id:"features-3",level:3},{value:"Implementation Details",id:"implementation-details-3",level:3},{value:"Java Support",id:"java-support",level:2},{value:"Features",id:"features-4",level:3},{value:"Implementation Details",id:"implementation-details-4",level:3},{value:"Rust Support",id:"rust-support",level:2},{value:"Features",id:"features-5",level:3},{value:"Implementation Details",id:"implementation-details-5",level:3},{value:"C Support",id:"c-support",level:2},{value:"Features",id:"features-6",level:3},{value:"Implementation Details",id:"implementation-details-6",level:3},{value:"Value Conversion Between Languages",id:"value-conversion-between-languages",level:2},{value:"Loader Implementation Architecture",id:"loader-implementation-architecture",level:2},{value:"Conclusion",id:"conclusion",level:2}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,l.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"supported-languages",children:"Supported Languages"})}),"\n",(0,s.jsxs)(n.p,{children:["This page provides a comprehensive overview of programming languages supported by MetaCall, including their integration levels, supported features, and implementation details. For information about the general architecture of MetaCall, see ",(0,s.jsx)(n.a,{href:"/doc/pr-17/docs/metacall-core/architecture",children:"Architecture"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"language-support-overview",children:"Language Support Overview"}),"\n",(0,s.jsx)(n.p,{children:"MetaCall enables cross-language function calls between multiple programming languages with varying degrees of integration. Each supported language has a corresponding loader that enables MetaCall to interface with the language's runtime environment and execute code written in that language."}),"\n",(0,s.jsx)(n.p,{children:"The following diagram illustrates the languages currently supported by MetaCall:"}),"\n",(0,s.jsx)(n.h2,{id:"integration-levels",children:"Integration Levels"}),"\n",(0,s.jsx)(n.p,{children:"Languages in MetaCall are integrated at different levels, depending on the features supported and the maturity of the implementation:"}),"\n",(0,s.jsx)(n.h2,{id:"feature-support-matrix",children:"Feature Support Matrix"}),"\n",(0,s.jsx)(n.p,{children:"The following table summarizes the key features supported across different languages:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Language"}),(0,s.jsx)(n.th,{children:"Function Calls"}),(0,s.jsx)(n.th,{children:"Classes & Objects"}),(0,s.jsx)(n.th,{children:"Async/Await"}),(0,s.jsx)(n.th,{children:"Exception Handling"}),(0,s.jsx)(n.th,{children:"Value Conversion"}),(0,s.jsx)(n.th,{children:"Garbage Collection"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Python"}),(0,s.jsx)(n.td,{children:"\u2713"}),(0,s.jsx)(n.td,{children:"\u2713"}),(0,s.jsx)(n.td,{children:"\u2713"}),(0,s.jsx)(n.td,{children:"\u2713"}),(0,s.jsx)(n.td,{children:"\u2713"}),(0,s.jsx)(n.td,{children:"\u2713"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Node.js"}),(0,s.jsx)(n.td,{children:"\u2713"}),(0,s.jsx)(n.td,{children:"\u2713"}),(0,s.jsx)(n.td,{children:"\u2713"}),(0,s.jsx)(n.td,{children:"\u2713"}),(0,s.jsx)(n.td,{children:"\u2713"}),(0,s.jsx)(n.td,{children:"\u2713"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"TypeScript"}),(0,s.jsx)(n.td,{children:"\u2713"}),(0,s.jsx)(n.td,{children:"\u2713"}),(0,s.jsx)(n.td,{children:"\u2713"}),(0,s.jsx)(n.td,{children:"\u2713"}),(0,s.jsx)(n.td,{children:"\u2713"}),(0,s.jsx)(n.td,{children:"\u2713"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Ruby"}),(0,s.jsx)(n.td,{children:"\u2713"}),(0,s.jsx)(n.td,{children:"\u2713"}),(0,s.jsx)(n.td,{children:"Limited"}),(0,s.jsx)(n.td,{children:"\u2713"}),(0,s.jsx)(n.td,{children:"\u2713"}),(0,s.jsx)(n.td,{children:"\u2713"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Java"}),(0,s.jsx)(n.td,{children:"\u2713"}),(0,s.jsx)(n.td,{children:"\u2713"}),(0,s.jsx)(n.td,{children:"Limited"}),(0,s.jsx)(n.td,{children:"\u2713"}),(0,s.jsx)(n.td,{children:"\u2713"}),(0,s.jsx)(n.td,{children:"\u2713"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"C"}),(0,s.jsx)(n.td,{children:"\u2713"}),(0,s.jsx)(n.td,{children:"Limited"}),(0,s.jsx)(n.td,{children:"\u2717"}),(0,s.jsx)(n.td,{children:"Limited"}),(0,s.jsx)(n.td,{children:"\u2713"}),(0,s.jsx)(n.td,{children:"Manual"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Rust"}),(0,s.jsx)(n.td,{children:"\u2713"}),(0,s.jsx)(n.td,{children:"Limited"}),(0,s.jsx)(n.td,{children:"\u2717"}),(0,s.jsx)(n.td,{children:"Limited"}),(0,s.jsx)(n.td,{children:"\u2713"}),(0,s.jsx)(n.td,{children:"\u2713"})]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"python-support",children:"Python Support"}),"\n",(0,s.jsx)(n.p,{children:"Python is fully integrated into MetaCall using direct bindings to the Python C API."}),"\n",(0,s.jsx)(n.h3,{id:"features",children:"Features"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Complete Function Support"}),": Call Python functions with arguments and receive return values"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Class and Object Support"}),": Instantiate and interact with Python classes and objects"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Async/Await"}),": Support for Python's asynchronous programming model"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Exception Handling"}),": Python exceptions are properly captured and converted"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Value Conversion"}),": Bidirectional conversion between Python types and MetaCall values"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"implementation-details",children:"Implementation Details"}),"\n",(0,s.jsxs)(n.p,{children:["The Python loader (",(0,s.jsx)(n.code,{children:"py_loader"}),") directly interfaces with the Python C API to execute Python code. It handles:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Function discovery and reflection"}),"\n",(0,s.jsx)(n.li,{children:"Class and method discovery"}),"\n",(0,s.jsx)(n.li,{children:"Object instantiation and method calls"}),"\n",(0,s.jsx)(n.li,{children:"Asynchronous function execution"}),"\n",(0,s.jsx)(n.li,{children:"Value type conversion"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"nodejs-support",children:"Node.js Support"}),"\n",(0,s.jsx)(n.p,{children:"Node.js/JavaScript has full integration with comprehensive support for modern JavaScript features."}),"\n",(0,s.jsx)(n.h3,{id:"features-1",children:"Features"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Function Calls"}),": Call JavaScript functions with arguments and receive return values"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Promise Support"}),": Native handling of JavaScript promises"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Async/Await"}),": Full support for async/await patterns"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Exception Handling"}),": JavaScript exceptions are properly captured and converted"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Value Conversion"}),": Bidirectional conversion between JavaScript types and MetaCall values"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"implementation-details-1",children:"Implementation Details"}),"\n",(0,s.jsxs)(n.p,{children:["The Node.js loader (",(0,s.jsx)(n.code,{children:"node_loader"}),") uses N-API (Node.js API) and a JavaScript bridge for integration. It implements:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"A bootstrap mechanism to initialize the Node.js environment"}),"\n",(0,s.jsx)(n.li,{children:"Thread-safe function calls between MetaCall and Node.js"}),"\n",(0,s.jsx)(n.li,{children:"Promise and async/await support"}),"\n",(0,s.jsx)(n.li,{children:"Complex value conversion between JavaScript and MetaCall types"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"typescript-support",children:"TypeScript Support"}),"\n",(0,s.jsx)(n.p,{children:"TypeScript is fully supported through the Node.js loader with additional TypeScript-specific functionality."}),"\n",(0,s.jsx)(n.h3,{id:"features-2",children:"Features"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"All Node.js/JavaScript features"}),"\n",(0,s.jsx)(n.li,{children:"Static type checking and type information"}),"\n",(0,s.jsx)(n.li,{children:"TypeScript-specific language constructs"}),"\n",(0,s.jsx)(n.li,{children:"Automatic transpilation to JavaScript"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"implementation-details-2",children:"Implementation Details"}),"\n",(0,s.jsxs)(n.p,{children:["The TypeScript loader (",(0,s.jsx)(n.code,{children:"ts_loader"}),") builds on top of the Node.js loader, adding:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"TypeScript compilation using the TypeScript compiler API"}),"\n",(0,s.jsx)(n.li,{children:"Type information discovery"}),"\n",(0,s.jsx)(n.li,{children:"Source file loading and transpilation"}),"\n",(0,s.jsx)(n.li,{children:"Integration with the JavaScript execution environment"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The TypeScript loader first transpiles TypeScript code to JavaScript, then uses the Node.js loader to execute it."}),"\n",(0,s.jsx)(n.h2,{id:"ruby-support",children:"Ruby Support"}),"\n",(0,s.jsx)(n.p,{children:"Ruby has partial integration with support for core Ruby features."}),"\n",(0,s.jsx)(n.h3,{id:"features-3",children:"Features"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Function Calls"}),": Call Ruby functions with arguments and receive return values"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Class and Object Support"}),": Instantiate and interact with Ruby classes and objects"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Limited Async Support"}),": Basic support for Ruby's asynchronous patterns"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Exception Handling"}),": Ruby exceptions are properly captured and converted"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Value Conversion"}),": Bidirectional conversion between Ruby types and MetaCall values"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"implementation-details-3",children:"Implementation Details"}),"\n",(0,s.jsxs)(n.p,{children:["The Ruby loader (",(0,s.jsx)(n.code,{children:"rb_loader"}),") interfaces directly with the Ruby C API. It implements:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Function discovery and invocation"}),"\n",(0,s.jsx)(n.li,{children:"Class and method discovery"}),"\n",(0,s.jsx)(n.li,{children:"Object instantiation and method calls"}),"\n",(0,s.jsx)(n.li,{children:"Value type conversion between Ruby and MetaCall"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"java-support",children:"Java Support"}),"\n",(0,s.jsx)(n.p,{children:"Java has partial integration with support for Java classes and methods."}),"\n",(0,s.jsx)(n.h3,{id:"features-4",children:"Features"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Function Calls"}),": Invoke Java methods with arguments and receive return values"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Class and Object Support"}),": Instantiate and interact with Java classes and objects"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Limited Async Support"}),": Basic support for Java's asynchronous patterns"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Exception Handling"}),": Java exceptions are properly captured and converted"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Value Conversion"}),": Bidirectional conversion between Java types and MetaCall values"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"implementation-details-4",children:"Implementation Details"}),"\n",(0,s.jsxs)(n.p,{children:["The Java loader (",(0,s.jsx)(n.code,{children:"java_loader"}),") uses JNI (Java Native Interface) to interact with the Java Virtual Machine. It handles:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Java class loading and instantiation"}),"\n",(0,s.jsx)(n.li,{children:"Method discovery and invocation"}),"\n",(0,s.jsx)(n.li,{children:"Field access and modification"}),"\n",(0,s.jsx)(n.li,{children:"Static and instance method calls"}),"\n",(0,s.jsx)(n.li,{children:"Value type conversion between Java and MetaCall"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The Java loader uses a bootstrap mechanism with pre-compiled Java code for initialization."}),"\n",(0,s.jsx)(n.h2,{id:"rust-support",children:"Rust Support"}),"\n",(0,s.jsx)(n.p,{children:"Rust has basic integration with support for function calls."}),"\n",(0,s.jsx)(n.h3,{id:"features-5",children:"Features"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Function Calls"}),": Call Rust functions with arguments and receive return values"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Limited Object Support"}),": Basic support for Rust structs and traits"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Value Conversion"}),": Conversion between Rust types and MetaCall values"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"implementation-details-5",children:"Implementation Details"}),"\n",(0,s.jsxs)(n.p,{children:["The Rust loader (",(0,s.jsx)(n.code,{children:"rs_loader"}),") compiles Rust code into a shared library which is then loaded by MetaCall. It uses:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Rust's Foreign Function Interface (FFI)"}),"\n",(0,s.jsx)(n.li,{children:"CMake-based build system to compile Rust code"}),"\n",(0,s.jsx)(n.li,{children:"Value type conversion between Rust and MetaCall"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The Rust loader requires the Rust toolchain to be installed on the system."}),"\n",(0,s.jsx)(n.h2,{id:"c-support",children:"C Support"}),"\n",(0,s.jsx)(n.p,{children:"C has partial integration with support for basic function calls."}),"\n",(0,s.jsx)(n.h3,{id:"features-6",children:"Features"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Function Calls"}),": Call C functions with arguments and receive return values"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Limited Struct Support"}),": Basic support for C structs"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Value Conversion"}),": Conversion between C types and MetaCall values"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"implementation-details-6",children:"Implementation Details"}),"\n",(0,s.jsx)(n.p,{children:"The C loader enables loading and calling C functions from shared libraries or direct source code. It uses:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Dynamic library loading mechanisms"}),"\n",(0,s.jsx)(n.li,{children:"Tiny C Compiler (TCC) for JIT compilation of C code"}),"\n",(0,s.jsx)(n.li,{children:"Function discovery and invocation"}),"\n",(0,s.jsx)(n.li,{children:"Value type conversion between C and MetaCall"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"value-conversion-between-languages",children:"Value Conversion Between Languages"}),"\n",(0,s.jsx)(n.p,{children:"MetaCall implements a sophisticated value system that handles conversion between different language types:"}),"\n",(0,s.jsx)(n.p,{children:"The solid lines indicate full support, while the dotted lines indicate partial support."}),"\n",(0,s.jsx)(n.h2,{id:"loader-implementation-architecture",children:"Loader Implementation Architecture"}),"\n",(0,s.jsx)(n.p,{children:"Each language loader follows a common implementation pattern but with language-specific adaptations:"}),"\n",(0,s.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,s.jsx)(n.p,{children:"MetaCall supports a wide range of programming languages with varying levels of integration. Python, Node.js, and TypeScript have the most comprehensive support, including features like classes, async/await, and exception handling. Ruby and Java have good support for core features but more limited async capabilities. Rust and C have basic integration focusing on function calls."}),"\n",(0,s.jsx)(n.p,{children:"The language support continues to evolve with improvements to existing loaders and potential additions of new languages in the future."})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>a});var i=t(6540);const s={},l=i.createContext(s);function r(e){const n=i.useContext(l);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(l.Provider,{value:n},e.children)}}}]);