"use strict";(globalThis.webpackChunkmetacall_doc=globalThis.webpackChunkmetacall_doc||[]).push([[9497],{8453:(e,n,i)=>{i.d(n,{R:()=>t,x:()=>a});var l=i(6540);const s={},r=l.createContext(s);function t(e){const n=l.useContext(r);return l.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:t(e.components),l.createElement(r.Provider,{value:n},e.children)}},8824:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>t,metadata:()=>l,toc:()=>o});const l=JSON.parse('{"id":"metacall-core/repl-mode","title":"REPL Mode","description":"The MetaCall REPL (Read-Eval-Print Loop) provides an interactive shell environment for executing cross-language function calls and managing code loading across different programming languages. This page documents the REPL mode implementation, its architecture, and usage patterns.","source":"@site/docs/metacall-core/repl-mode.md","sourceDirName":"metacall-core","slug":"/metacall-core/repl-mode","permalink":"/doc/pr-17/docs/metacall-core/repl-mode","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"REPL Mode"},"sidebar":"tutorialSidebar","previous":{"title":"Python Port","permalink":"/doc/pr-17/docs/metacall-core/python-port"},"next":{"title":"Ruby Loader","permalink":"/doc/pr-17/docs/metacall-core/ruby-loader"}}');var s=i(4848),r=i(8453);const t={title:"REPL Mode"},a="REPL Mode",d={},o=[{value:"Overview",id:"overview",level:2},{value:"Architecture",id:"architecture",level:2},{value:"REPL System Components",id:"repl-system-components",level:3},{value:"REPL Execution Flow",id:"repl-execution-flow",level:3},{value:"Initialization Process",id:"initialization-process",level:2},{value:"Command Processing",id:"command-processing",level:2},{value:"Command Format",id:"command-format",level:3},{value:"Command Registration and Parsing",id:"command-registration-and-parsing",level:3},{value:"Command Execution Flow",id:"command-execution-flow",level:3},{value:"Plugin System",id:"plugin-system",level:2},{value:"REPL Implementation Details",id:"repl-implementation-details",level:2},{value:"REPL Promise Chain",id:"repl-promise-chain",level:2},{value:"Error Handling",id:"error-handling",level:2},{value:"Exiting the REPL",id:"exiting-the-repl",level:2},{value:"Available Commands",id:"available-commands",level:2},{value:"Example Usage",id:"example-usage",level:2}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"repl-mode",children:"REPL Mode"})}),"\n",(0,s.jsxs)(n.p,{children:["The MetaCall REPL (Read-Eval-Print Loop) provides an interactive shell environment for executing cross-language function calls and managing code loading across different programming languages. This page documents the REPL mode implementation, its architecture, and usage patterns.\nFor information about CLI commands available in the REPL, see ",(0,s.jsx)(n.a,{href:"/doc/pr-17/docs/metacall-core/cli-commands",children:"CLI Commands"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsx)(n.p,{children:"The REPL mode serves as an interactive interface to the MetaCall runtime, allowing developers to:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Load source files from different programming languages"}),"\n",(0,s.jsx)(n.li,{children:"Evaluate code snippets in various languages"}),"\n",(0,s.jsx)(n.li,{children:"Inspect loaded functions and objects"}),"\n",(0,s.jsx)(n.li,{children:"Call functions across language boundaries"}),"\n",(0,s.jsx)(n.li,{children:"Debug cross-language applications"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The REPL is automatically started when MetaCall CLI is launched without arguments."}),"\n",(0,s.jsx)(n.h2,{id:"architecture",children:"Architecture"}),"\n",(0,s.jsx)(n.h3,{id:"repl-system-components",children:"REPL System Components"}),"\n",(0,s.jsx)(n.h3,{id:"repl-execution-flow",children:"REPL Execution Flow"}),"\n",(0,s.jsx)(n.h2,{id:"initialization-process",children:"Initialization Process"}),"\n",(0,s.jsx)(n.p,{children:"The REPL mode is initialized when:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"The MetaCall CLI is launched without arguments"}),"\n",(0,s.jsx)(n.li,{children:"The CLI is launched with options but no positional arguments (files to execute)"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"During initialization, the following steps are performed:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["Load CLI internal plugins from the ",(0,s.jsx)(n.code,{children:"internal"})," directory"]}),"\n",(0,s.jsxs)(n.li,{children:["Load REPL plugins from the ",(0,s.jsx)(n.code,{children:"repl"})," directory"]}),"\n",(0,s.jsxs)(n.li,{children:["Register the ",(0,s.jsx)(n.code,{children:"exit"})," function for terminating the REPL"]}),"\n",(0,s.jsx)(n.li,{children:"Initialize REPL descriptors from plugin path"}),"\n",(0,s.jsx)(n.li,{children:"Start the Node.js-based REPL interface"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"command-processing",children:"Command Processing"}),"\n",(0,s.jsx)(n.h3,{id:"command-format",children:"Command Format"}),"\n",(0,s.jsx)(n.p,{children:"Commands in the REPL follow a specific structure:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"command [arg1] [arg2] ...\n"})}),"\n",(0,s.jsx)(n.p,{children:"The first token is treated as the command name, and subsequent tokens are passed as arguments to the command handler."}),"\n",(0,s.jsx)(n.h3,{id:"command-registration-and-parsing",children:"Command Registration and Parsing"}),"\n",(0,s.jsx)(n.p,{children:"Commands are registered in the REPL using a registration system that specifies:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Command name"}),"\n",(0,s.jsx)(n.li,{children:"Regular expressions for parsing arguments"}),"\n",(0,s.jsx)(n.li,{children:"Expected argument types"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"command-execution-flow",children:"Command Execution Flow"}),"\n",(0,s.jsx)(n.p,{children:"When a command is executed:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"The command string is parsed into tokens"}),"\n",(0,s.jsx)(n.li,{children:"The first token identifies the command"}),"\n",(0,s.jsx)(n.li,{children:"If the command is registered, the handler is called with the remaining tokens"}),"\n",(0,s.jsx)(n.li,{children:"The result is returned and displayed in the REPL"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"execute"})," method in the application class handles this process:"]}),"\n",(0,s.jsx)(n.h2,{id:"plugin-system",children:"Plugin System"}),"\n",(0,s.jsx)(n.p,{children:"The REPL mode uses a plugin system to extend its functionality. Plugins are loaded from:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"${METACALL_PLUGIN_PATH}/cli/repl/${plugin_name}/${plugin_name}_repl.js\n"})}),"\n",(0,s.jsx)(n.p,{children:"Each plugin can register new commands and provide implementations for those commands."}),"\n",(0,s.jsx)(n.h2,{id:"repl-implementation-details",children:"REPL Implementation Details"}),"\n",(0,s.jsx)(n.p,{children:"The REPL is implemented using the Node.js built-in REPL module, customized with MetaCall-specific evaluator and completer functions:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Component"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Prompt"}),(0,s.jsx)(n.td,{children:"Uses the lambda symbol (\u03bb) to indicate input readiness"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Context"}),(0,s.jsx)(n.td,{children:"Provides an isolated VM context for evaluation"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Evaluator"}),(0,s.jsx)(n.td,{children:"Custom function that processes commands through the MetaCall parser"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Completer"}),(0,s.jsx)(n.td,{children:"Provides command completion based on registered commands"})]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"repl-promise-chain",children:"REPL Promise Chain"}),"\n",(0,s.jsx)(n.p,{children:"The REPL implementation uses a promise chain mechanism to manage the asynchronous nature of command evaluation:"}),"\n",(0,s.jsx)(n.p,{children:"This allows the CLI main loop to wait for each command to complete before accepting new input."}),"\n",(0,s.jsx)(n.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,s.jsx)(n.p,{children:"The REPL mode includes comprehensive error handling to:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Capture parsing errors from malformed commands"}),"\n",(0,s.jsx)(n.li,{children:"Handle exceptions from command execution"}),"\n",(0,s.jsx)(n.li,{children:"Manage errors from cross-language function calls"}),"\n",(0,s.jsx)(n.li,{children:"Provide meaningful error messages to users"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"When an error occurs:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"If during parsing: The error is wrapped and returned to the application"}),"\n",(0,s.jsx)(n.li,{children:"If during execution: The exception is captured and displayed with its stack trace"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"exiting-the-repl",children:"Exiting the REPL"}),"\n",(0,s.jsx)(n.p,{children:"The REPL mode can be terminated by:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["Using the ",(0,s.jsx)(n.code,{children:"exit"})," command"]}),"\n",(0,s.jsx)(n.li,{children:"Pressing Ctrl+C (SIGINT) or Ctrl+D (EOF)"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["The exit function sets the ",(0,s.jsx)(n.code,{children:"exit_condition"})," flag to true, which breaks the main REPL loop and performs cleanup operations."]}),"\n",(0,s.jsx)(n.h2,{id:"available-commands",children:"Available Commands"}),"\n",(0,s.jsx)(n.p,{children:"The REPL comes with a set of built-in commands loaded from the core plugin. These commands include:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Command"}),(0,s.jsx)(n.th,{children:"Purpose"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"load <tag> <files...>"})}),(0,s.jsx)(n.td,{children:"Load source files with specified loader"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"inspect"})}),(0,s.jsx)(n.td,{children:"List all loaded functions"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"eval <tag> <code>"})}),(0,s.jsx)(n.td,{children:"Evaluate code snippet with specified loader"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"call <function>(<args>)"})}),(0,s.jsx)(n.td,{children:"Call a function with arguments"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"clear <tag> <file>"})}),(0,s.jsx)(n.td,{children:"Clear a loaded module"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"help"})}),(0,s.jsx)(n.td,{children:"Display help information"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"copyright"})}),(0,s.jsx)(n.td,{children:"Show copyright information"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"exit"})}),(0,s.jsx)(n.td,{children:"Exit the REPL"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Additional commands may be available through plugins."}),(0,s.jsx)(n.td,{})]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"example-usage",children:"Example Usage"}),"\n",(0,s.jsx)(n.p,{children:"Here's a typical usage scenario of the REPL mode:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'$ metacall\n\nWelcome to Tijuana, tequila, sexo & marijuana.\n\u03bb load py hello.py\n\u03bb inspect\nhello.greet\n\u03bb call hello.greet("world")\nHello, world!\n\u03bb eval node console.log("JavaScript code in REPL")\nJavaScript code in REPL\n\u03bb exit\nExiting ...\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Sources: ",(0,s.jsx)(n.a,{href:"https://github.com/metacall/core/blob/af9cad19/source/cli/plugins/cli_repl_plugin/source/cli_repl_plugin.js#L72-L72",children:"source/cli/plugins/cli_repl_plugin/source/cli_repl_plugin.js72"})," ",(0,s.jsx)(n.a,{href:"https://github.com/metacall/core/blob/af9cad19/source/cli/metacallcli/source/application.cpp#L62-L63",children:"source/cli/metacallcli/source/application.cpp62-63"})]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}}}]);