"use strict";(globalThis.webpackChunkmetacall_doc=globalThis.webpackChunkmetacall_doc||[]).push([[1857],{48:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>o,contentTitle:()=>a,default:()=>h,frontMatter:()=>l,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"metacall-core/sanitizers","title":"Sanitizers","description":"Relevant source files","source":"@site/docs/metacall-core/sanitizers.md","sourceDirName":"metacall-core","slug":"/metacall-core/sanitizers","permalink":"/doc/docs/metacall-core/sanitizers","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Sanitizers"},"sidebar":"tutorialSidebar","previous":{"title":"Rust Port","permalink":"/doc/docs/metacall-core/rust-port"},"next":{"title":"Serialization and Value System","permalink":"/doc/docs/metacall-core/serialization-and-value-system"}}');var n=i(4848),r=i(8453);const l={title:"Sanitizers"},a="Sanitizers",o={},c=[{value:"Relevant source files",id:"relevant-source-files",level:2},{value:"Overview of Sanitizers",id:"overview-of-sanitizers",level:2},{value:"Sanitizer Integration in Build System",id:"sanitizer-integration-in-build-system",level:2},{value:"Enabling Sanitizers",id:"enabling-sanitizers",level:2},{value:"Command Line Options",id:"command-line-options",level:3},{value:"Sanitizers and Memcheck",id:"sanitizers-and-memcheck",level:2},{value:"Platform Support for Sanitizers",id:"platform-support-for-sanitizers",level:2},{value:"Sanitizers in CI Workflows",id:"sanitizers-in-ci-workflows",level:2},{value:"Reading Sanitizer Output",id:"reading-sanitizer-output",level:2},{value:"Best Practices for Using Sanitizers",id:"best-practices-for-using-sanitizers",level:2},{value:"Environment Variables for Sanitizers",id:"environment-variables-for-sanitizers",level:2},{value:"Conclusion",id:"conclusion",level:2}];function d(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.header,{children:(0,n.jsx)(t.h1,{id:"sanitizers",children:"Sanitizers"})}),"\n",(0,n.jsx)(t.h2,{id:"relevant-source-files",children:"Relevant source files"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"https://github.com/metacall/core/blob/af9cad19/.env",children:".env"})}),"\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"https://github.com/metacall/core/blob/af9cad19/.github/workflows/benchmark.yml",children:".github/workflows/benchmark.yml"})}),"\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"https://github.com/metacall/core/blob/af9cad19/.github/workflows/clang-format.yml",children:".github/workflows/clang-format.yml"})}),"\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"https://github.com/metacall/core/blob/af9cad19/.github/workflows/docker-hub.yml",children:".github/workflows/docker-hub.yml"})}),"\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"https://github.com/metacall/core/blob/af9cad19/.github/workflows/linux-test.yml",children:".github/workflows/linux-test.yml"})}),"\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"https://github.com/metacall/core/blob/af9cad19/.github/workflows/macos-test.yml",children:".github/workflows/macos-test.yml"})}),"\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"https://github.com/metacall/core/blob/af9cad19/.github/workflows/release.yml",children:".github/workflows/release.yml"})}),"\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"https://github.com/metacall/core/blob/af9cad19/.github/workflows/windows-test.yml",children:".github/workflows/windows-test.yml"})}),"\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"https://github.com/metacall/core/blob/af9cad19/CMakeLists.txt",children:"CMakeLists.txt"})}),"\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"https://github.com/metacall/core/blob/af9cad19/README.md",children:"README.md"})}),"\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"https://github.com/metacall/core/blob/af9cad19/deploy/images/overview.png",children:"deploy/images/overview.png"})}),"\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"https://github.com/metacall/core/blob/af9cad19/docker-compose.platform.yml",children:"docker-compose.platform.yml"})}),"\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"https://github.com/metacall/core/blob/af9cad19/docker-compose.yml",children:"docker-compose.yml"})}),"\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"https://github.com/metacall/core/blob/af9cad19/docs/README.md",children:"docs/README.md"})}),"\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"https://github.com/metacall/core/blob/af9cad19/source/CMakeLists.txt",children:"source/CMakeLists.txt"})}),"\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"https://github.com/metacall/core/blob/af9cad19/source/loaders/CMakeLists.txt",children:"source/loaders/CMakeLists.txt"})}),"\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"https://github.com/metacall/core/blob/af9cad19/source/scripts/python/CMakeLists.txt",children:"source/scripts/python/CMakeLists.txt"})}),"\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"https://github.com/metacall/core/blob/af9cad19/source/tests/CMakeLists.txt",children:"source/tests/CMakeLists.txt"})}),"\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"https://github.com/metacall/core/blob/af9cad19/tools/metacall-benchmarks-merge.py",children:"tools/metacall-benchmarks-merge.py"})}),"\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"https://github.com/metacall/core/blob/af9cad19/tools/metacall-build.ps1",children:"tools/metacall-build.ps1"})}),"\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"https://github.com/metacall/core/blob/af9cad19/tools/metacall-build.sh",children:"tools/metacall-build.sh"})}),"\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"https://github.com/metacall/core/blob/af9cad19/tools/metacall-configure.ps1",children:"tools/metacall-configure.ps1"})}),"\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"https://github.com/metacall/core/blob/af9cad19/tools/metacall-configure.sh",children:"tools/metacall-configure.sh"})}),"\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"https://github.com/metacall/core/blob/af9cad19/tools/metacall-environment.ps1",children:"tools/metacall-environment.ps1"})}),"\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"https://github.com/metacall/core/blob/af9cad19/tools/metacall-environment.sh",children:"tools/metacall-environment.sh"})}),"\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"https://github.com/metacall/core/blob/af9cad19/tools/metacall-runtime.sh",children:"tools/metacall-runtime.sh"})}),"\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"https://github.com/metacall/core/blob/af9cad19/tools/metacall-sanitizer.sh",children:"tools/metacall-sanitizer.sh"})}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"Sanitizers are powerful diagnostic tools integrated into the MetaCall build system to detect runtime errors that might otherwise be difficult to find. This page documents the sanitizer options available in MetaCall, how they are configured, and how they are used in the continuous integration (CI) pipeline for quality assurance."}),"\n",(0,n.jsx)(t.h2,{id:"overview-of-sanitizers",children:"Overview of Sanitizers"}),"\n",(0,n.jsx)(t.p,{children:"Sanitizers are compiler-based dynamic analysis tools that can detect various types of bugs during program execution. MetaCall supports three main types of sanitizers:"}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Address Sanitizer (ASan)"})," - Detects memory errors such as buffer overflows, use-after-free, double-free, and memory leaks"]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Thread Sanitizer (TSan)"})," - Detects data races and other threading issues"]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Memory Sanitizer (MSan)"})," - Detects uses of uninitialized memory"]}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"Each sanitizer is designed to catch different categories of bugs, and they can significantly improve the reliability of the MetaCall codebase by identifying issues that might otherwise go undetected."}),"\n",(0,n.jsx)(t.h2,{id:"sanitizer-integration-in-build-system",children:"Sanitizer Integration in Build System"}),"\n",(0,n.jsx)(t.p,{children:"The sanitizers are integrated into MetaCall's CMake build system as build options. These options can be enabled during configuration."}),"\n",(0,n.jsx)(t.p,{children:"The sanitizer options are defined in the main CMakeLists.txt file and can be passed to the configuration scripts."}),"\n",(0,n.jsx)(t.h2,{id:"enabling-sanitizers",children:"Enabling Sanitizers"}),"\n",(0,n.jsxs)(t.p,{children:["Sanitizers can be enabled using the ",(0,n.jsx)(t.code,{children:"metacall-configure.sh"})," script with appropriate flags. Only one sanitizer should be enabled at a time since they may conflict with each other."]}),"\n",(0,n.jsx)(t.h3,{id:"command-line-options",children:"Command Line Options"}),"\n",(0,n.jsx)(t.p,{children:"To enable a sanitizer, use one of the following options when configuring the build:"}),"\n",(0,n.jsxs)(t.p,{children:["Alternatively, you can use the dedicated script ",(0,n.jsx)(t.code,{children:"metacall-sanitizer.sh"})," which streamlines the process of building and testing with sanitizers:"]}),"\n",(0,n.jsx)(t.h2,{id:"sanitizers-and-memcheck",children:"Sanitizers and Memcheck"}),"\n",(0,n.jsx)(t.p,{children:"It's important to note that sanitizers and memcheck (Valgrind) are not compatible with each other. If you attempt to use both, the build system will disable memcheck tests and issue a warning."}),"\n",(0,n.jsx)(t.h2,{id:"platform-support-for-sanitizers",children:"Platform Support for Sanitizers"}),"\n",(0,n.jsx)(t.p,{children:"Sanitizer support varies by platform:"}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{children:"Sanitizer"}),(0,n.jsx)(t.th,{children:"Linux"}),(0,n.jsx)(t.th,{children:"macOS"}),(0,n.jsx)(t.th,{children:"Windows"})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"Address Sanitizer"}),(0,n.jsx)(t.td,{children:"\u2713"}),(0,n.jsx)(t.td,{children:"\u2713"}),(0,n.jsx)(t.td,{children:"\u2713"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"Thread Sanitizer"}),(0,n.jsx)(t.td,{children:"\u2713"}),(0,n.jsx)(t.td,{children:"\u2713"}),(0,n.jsx)(t.td,{children:"\u274c"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"Memory Sanitizer"}),(0,n.jsx)(t.td,{children:"\u2713"}),(0,n.jsx)(t.td,{children:"\u274c"}),(0,n.jsx)(t.td,{children:"\u274c"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"Windows support for Thread Sanitizer and Memory Sanitizer is currently limited or non-existent because these sanitizers are not fully supported by the MSVC compiler."}),(0,n.jsx)(t.td,{}),(0,n.jsx)(t.td,{}),(0,n.jsx)(t.td,{})]})]})]}),"\n",(0,n.jsx)(t.h2,{id:"sanitizers-in-ci-workflows",children:"Sanitizers in CI Workflows"}),"\n",(0,n.jsx)(t.p,{children:"MetaCall uses sanitizers in continuous integration (CI) workflows to detect issues automatically. The CI system runs tests with different sanitizers enabled on various platforms."}),"\n",(0,n.jsx)(t.p,{children:"The GitHub Actions workflows are configured to run tests with different sanitizers on different platforms. If a sanitizer detects an issue, the corresponding CI job will fail, alerting developers to the problem."}),"\n",(0,n.jsx)(t.h2,{id:"reading-sanitizer-output",children:"Reading Sanitizer Output"}),"\n",(0,n.jsx)(t.p,{children:"When a sanitizer detects an issue, it produces an error report that helps identify the problem. Here's how to interpret the sanitizer output:"}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Error Type"}),": The sanitizer will indicate what type of error it found (e.g., heap-use-after-free, stack-buffer-overflow)"]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Location"}),": The report includes the source file, function, and line number where the error occurred"]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Stack Trace"}),": A stack trace showing the call path that led to the error"]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Memory Addresses"}),": For memory-related errors, information about the relevant memory addresses"]}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"When investigating a sanitizer error, start by looking at the error type and the location information, then examine the code at that location and the associated stack trace."}),"\n",(0,n.jsx)(t.h2,{id:"best-practices-for-using-sanitizers",children:"Best Practices for Using Sanitizers"}),"\n",(0,n.jsx)(t.p,{children:"To get the most out of sanitizers in MetaCall development:"}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Run with debug builds"}),": Sanitizers work best with debug builds that include detailed symbol information"]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Use one sanitizer at a time"}),": Each sanitizer has its own focus and may conflict with others"]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Incorporate sanitizers into your development workflow"}),": Run tests with sanitizers locally before pushing changes"]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Address all sanitizer warnings"}),": Even seemingly minor issues can indicate deeper problems"]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Document known false positives"}),": Some sanitizer warnings may be false positives due to third-party code or intentional design decisions"]}),"\n"]}),"\n",(0,n.jsx)(t.h2,{id:"environment-variables-for-sanitizers",children:"Environment Variables for Sanitizers"}),"\n",(0,n.jsx)(t.p,{children:"When running with sanitizers enabled, several environment variables can control their behavior:"}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{children:"Environment Variable"}),(0,n.jsx)(t.th,{children:"Description"})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"ASAN_OPTIONS"})}),(0,n.jsx)(t.td,{children:"Controls Address Sanitizer behavior"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"TSAN_OPTIONS"})}),(0,n.jsx)(t.td,{children:"Controls Thread Sanitizer behavior"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"MSAN_OPTIONS"})}),(0,n.jsx)(t.td,{children:"Controls Memory Sanitizer behavior"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"SANITIZER_SKIP_SUMMARY"})}),(0,n.jsx)(t.td,{children:"When set to 1, suppresses sanitizer summary output (used in CI)"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"For example, to enable leak detection in Address Sanitizer:"}),(0,n.jsx)(t.td,{})]})]})]}),"\n",(0,n.jsx)(t.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,n.jsx)(t.p,{children:"Sanitizers are valuable tools in the MetaCall development process, helping to catch memory and threading bugs that might otherwise be difficult to detect. By enabling sanitizers during development and testing, contributors can help maintain the stability and reliability of the MetaCall codebase."}),"\n",(0,n.jsxs)(t.p,{children:["For more information about testing in MetaCall, see the ",(0,n.jsx)(t.a,{href:"/doc/docs/metacall-core/testing-framework",children:"Testing Framework"})," page and ",(0,n.jsx)(t.a,{href:"/doc/docs/metacall-core/running-tests",children:"Running Tests"})," for specific instructions on executing the test suite."]})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},8453:(e,t,i)=>{i.d(t,{R:()=>l,x:()=>a});var s=i(6540);const n={},r=s.createContext(n);function l(e){const t=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:l(e.components),s.createElement(r.Provider,{value:t},e.children)}}}]);