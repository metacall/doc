"use strict";(globalThis.webpackChunkmetacall_doc=globalThis.webpackChunkmetacall_doc||[]).push([[1745],{8453:(e,n,i)=>{i.d(n,{R:()=>l,x:()=>r});var s=i(6540);const t={},a=s.createContext(t);function l(e){const n=s.useContext(a);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),s.createElement(a.Provider,{value:n},e.children)}},8973:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>r,default:()=>h,frontMatter:()=>l,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"metacall-core/architecture","title":"Architecture","description":"This page provides a comprehensive overview of the MetaCall Core architecture, explaining the structure and interactions between key components that enable cross-language function calls. For information about specific language support, see Supported Languages, and for details about using the core API, see Core API.","source":"@site/docs/metacall-core/architecture.md","sourceDirName":"metacall-core","slug":"/metacall-core/architecture","permalink":"/doc/docs/metacall-core/architecture","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Architecture"},"sidebar":"tutorialSidebar","previous":{"title":"Docker","permalink":"/doc/docs/installating-metacall-cli/Docker"},"next":{"title":"Build Configuration","permalink":"/doc/docs/metacall-core/build-configuration"}}');var t=i(4848),a=i(8453);const l={title:"Architecture"},r="Architecture",o={},c=[{value:"System Overview",id:"system-overview",level:2},{value:"Initialization and Runtime Flow",id:"initialization-and-runtime-flow",level:2},{value:"Core Components",id:"core-components",level:2},{value:"Reflection System",id:"reflection-system",level:3},{value:"Value System",id:"value-system",level:3},{value:"Loader System",id:"loader-system",level:3},{value:"Foreign Function Interface",id:"foreign-function-interface",level:2},{value:"Port System",id:"port-system",level:2},{value:"Build System",id:"build-system",level:2},{value:"Runtime Initialization Sequence",id:"runtime-initialization-sequence",level:2},{value:"Cross-Language Data Flow",id:"cross-language-data-flow",level:2},{value:"Summary",id:"summary",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"architecture",children:"Architecture"})}),"\n",(0,t.jsxs)(n.p,{children:["This page provides a comprehensive overview of the MetaCall Core architecture, explaining the structure and interactions between key components that enable cross-language function calls. For information about specific language support, see ",(0,t.jsx)(n.a,{href:"/doc/docs/metacall-core/supported-languages",children:"Supported Languages"}),", and for details about using the core API, see ",(0,t.jsx)(n.a,{href:"/doc/docs/metacall-core/core-api",children:"Core API"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"system-overview",children:"System Overview"}),"\n",(0,t.jsx)(n.p,{children:"MetaCall is designed as a modular system that enables seamless function calls between different programming languages. The architecture follows a plugin-based approach, with core components handling reflection, type conversion, and function dispatching."}),"\n",(0,t.jsx)(n.p,{children:"The architecture consists of four main components:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"MetaCall Core"}),": The central system that manages language interoperability through reflection, value conversion, serialization, and function hooking (detours)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Loader System"}),": Responsible for loading and executing code from different programming languages. Each loader specializes in a specific language runtime and bridges MetaCall core with the language's native environment."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Ports"}),": Provide language-specific interfaces to MetaCall, allowing developers to use MetaCall capabilities naturally from their preferred language."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"CLI & Tools"}),": Command-line interfaces and build tools for compiling, configuring, and using the MetaCall system."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"initialization-and-runtime-flow",children:"Initialization and Runtime Flow"}),"\n",(0,t.jsx)(n.p,{children:"The MetaCall initialization process establishes the runtime environment and prepares the system for cross-language function calls."}),"\n",(0,t.jsx)(n.p,{children:"The initialization sequence includes:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Core Initialization"}),": Sets up the MetaCall environment, including detours, serialization, and configuration."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Loader Manager Initialization"}),": Prepares the plugin system for language loaders."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Loader Registration"}),": Each language loader is registered with the system."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Runtime Integration"}),": When code is loaded, the appropriate language runtime is initialized if not already active."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Function Registration"}),": Functions from loaded code are registered in the reflection system for cross-language access."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"core-components",children:"Core Components"}),"\n",(0,t.jsx)(n.h3,{id:"reflection-system",children:"Reflection System"}),"\n",(0,t.jsx)(n.p,{children:"The reflection system provides introspection capabilities, allowing MetaCall to understand function signatures, types, and calling conventions across different languages."}),"\n",(0,t.jsx)(n.p,{children:"The reflection system maintains information about:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Contexts"}),": Represent execution environments, typically one per loaded module."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Scopes"}),": Contain functions, objects, and other symbols within a context."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Functions"}),": Represent callable code with signatures and implementations."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Signatures"}),": Define the parameter types and return type of functions."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Types"}),": Describe data types across language boundaries."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"value-system",children:"Value System"}),"\n",(0,t.jsx)(n.p,{children:"The value system provides a common representation for data across different languages, enabling type conversion and function parameter passing."}),"\n",(0,t.jsx)(n.p,{children:"The value system provides:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Common Type Representation"}),": A unified type system that maps between language-specific types."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Value Creation Functions"}),": Functions like ",(0,t.jsx)(n.code,{children:"metacall_value_create_*"})," to create values of different types."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Value Conversion"}),": Functions to convert between different types when needed."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Memory Management"}),": Consistent allocation and deallocation of values."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"loader-system",children:"Loader System"}),"\n",(0,t.jsx)(n.p,{children:"The loader system manages language-specific loaders, which are responsible for integrating different language runtimes with MetaCall."}),"\n",(0,t.jsx)(n.p,{children:"The loader system includes:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Loader Manager"}),": Coordinates all loaders and manages their lifecycle."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Plugin System"}),": Enables dynamic loading of language loaders as plugins."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Common Interface"}),": A standardized interface that all loaders implement."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Language-Specific Loaders"}),": Specialized implementations for each supported language."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Each loader implements the following interface methods:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"initialize"}),": Sets up the language runtime."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"execution_path"}),": Configures the paths where code is loaded from."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"load_from_file"}),": Loads code from files."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"load_from_memory"}),": Loads code from memory buffers."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"load_from_package"}),": Loads code from packages."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"clear"}),": Unloads modules."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"discover"}),": Introspects loaded modules to find functions and types."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"destroy"}),": Cleans up resources."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"foreign-function-interface",children:"Foreign Function Interface"}),"\n",(0,t.jsx)(n.p,{children:"The foreign function interface (FFI) is the core mechanism that allows calls between different languages. It handles function discovery, parameter passing, type conversion, and return value handling."}),"\n",(0,t.jsx)(n.p,{children:"The FFI provides several methods for calling functions:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"metacall"}),": Call a function by name with variable arguments."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"metacallv"}),": Call a function by name with an array of values."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"metacallhv"}),": Call a function by handle and name with an array of values."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"metacallfv"}),": Call a function directly with an array of values."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"These functions handle type conversion between languages, ensuring that data is correctly interpreted across language boundaries."}),"\n",(0,t.jsx)(n.h2,{id:"port-system",children:"Port System"}),"\n",(0,t.jsx)(n.p,{children:"The port system provides language-specific interfaces to MetaCall, allowing developers to use MetaCall capabilities from their preferred language with a natural API."}),"\n",(0,t.jsx)(n.p,{children:"Ports provide:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Native API"}),": A language-specific API that feels natural to users of that language."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Type Mapping"}),": Automatic conversion between the language's native types and MetaCall types."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Error Handling"}),": Appropriate error handling mechanisms for each language."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Memory Management"}),": Integration with the language's garbage collection or memory management system."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"build-system",children:"Build System"}),"\n",(0,t.jsx)(n.p,{children:"MetaCall uses a flexible build system that supports multiple platforms and configurations, allowing developers to customize which languages and features are included."}),"\n",(0,t.jsx)(n.p,{children:"The build system includes:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Environment Setup"}),": Scripts that install dependencies and prepare the development environment."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Build Configuration"}),": Scripts and CMake files that configure the build with options for which languages and features to include."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Build Process"}),": Scripts that compile the source code, run tests, and create Docker images."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Continuous Integration"}),": GitHub Actions workflows that automate testing, sanitizer checks, and code coverage analysis."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"runtime-initialization-sequence",children:"Runtime Initialization Sequence"}),"\n",(0,t.jsx)(n.p,{children:"When initializing MetaCall, a specific sequence of operations occurs to prepare the system for cross-language function calls."}),"\n",(0,t.jsx)(n.p,{children:"The initialization sequence includes:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Environment Variables"}),": Setting up necessary environment variables like ",(0,t.jsx)(n.code,{children:"METACALL_VERSION"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Detours System"}),": Initializing the function hooking mechanism."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Link System"}),": Setting up the linking between different components."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Fork Safety"}),": Preparing fork safety mechanisms if enabled."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Configuration"}),": Loading and processing configuration files."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Loader System"}),": Initializing the loader manager and registering loaders."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Plugins"}),": Loading core plugins for additional functionality."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"cross-language-data-flow",children:"Cross-Language Data Flow"}),"\n",(0,t.jsx)(n.p,{children:"When data flows between languages through MetaCall, it undergoes several transformations to ensure type compatibility."}),"\n",(0,t.jsx)(n.p,{children:"The data flow involves:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Source Language Type Mapping"}),": The source language's native type is mapped to a MetaCall type."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Value Conversion"}),": The source language's native value is converted to a MetaCall value."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Type Checking/Conversion"}),": If needed, the MetaCall value may be converted to match the expected type."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Target Language Conversion"}),": The MetaCall value is converted to the target language's native value."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"This process ensures that data can be correctly passed between languages with appropriate type conversion, even when the languages have different type systems."}),"\n",(0,t.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,t.jsx)(n.p,{children:"The MetaCall architecture provides a robust foundation for cross-language function calls, with modular components that handle different aspects of language interoperability. The core systems for reflection, value handling, and loading work together to enable seamless integration between different programming languages, while the build system and tools provide flexibility for developers to customize their MetaCall installation."}),"\n",(0,t.jsx)(n.p,{children:"The key strength of the architecture lies in its extensibility: new language loaders can be added as plugins, and the common interfaces ensure consistent behavior across different languages. This makes MetaCall a powerful tool for polyglot programming, allowing developers to leverage the strengths of different languages within a single application."})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}}}]);